(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/common'), require('@angular/core'), require('@angular/cdk/drag-drop'), require('rxjs'), require('rxjs/operators'), require('@angular/cdk/scrolling'), require('ngx-pagination')) :
    typeof define === 'function' && define.amd ? define('ngx-easy-table', ['exports', '@angular/common', '@angular/core', '@angular/cdk/drag-drop', 'rxjs', 'rxjs/operators', '@angular/cdk/scrolling', 'ngx-pagination'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global['ngx-easy-table'] = {}, global.ng.common, global.ng.core, global.ng.cdk.dragDrop, global.rxjs, global.rxjs.operators, global.ng.cdk.scrolling, global.ngxPagination));
}(this, (function (exports, common, core, dragDrop, rxjs, operators, scrolling, ngxPagination) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (Object.prototype.hasOwnProperty.call(b, p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function () {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __rest(s, e) {
        var t = {};
        for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }
    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if (d = decorators[i])
                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); };
    }
    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
    }
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator["throw"](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }
    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function () { if (t[0] & 1)
                throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f)
                throw new TypeError("Generator is already executing.");
            while (_)
                try {
                    if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                        return t;
                    if (y = 0, t)
                        op = [op[0] & 2, t.value];
                    switch (op[0]) {
                        case 0:
                        case 1:
                            t = op;
                            break;
                        case 4:
                            _.label++;
                            return { value: op[1], done: false };
                        case 5:
                            _.label++;
                            y = op[1];
                            op = [0];
                            continue;
                        case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;
                        default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                _ = 0;
                                continue;
                            }
                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                _.label = op[1];
                                break;
                            }
                            if (op[0] === 6 && _.label < t[1]) {
                                _.label = t[1];
                                t = op;
                                break;
                            }
                            if (t && _.label < t[2]) {
                                _.label = t[2];
                                _.ops.push(op);
                                break;
                            }
                            if (t[2])
                                _.ops.pop();
                            _.trys.pop();
                            continue;
                    }
                    op = body.call(thisArg, _);
                }
                catch (e) {
                    op = [6, e];
                    y = 0;
                }
                finally {
                    f = t = 0;
                }
            if (op[0] & 5)
                throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
        }
    }
    var __createBinding = Object.create ? (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
    }) : (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        o[k2] = m[k];
    });
    function __exportStar(m, o) {
        for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
                __createBinding(o, m, p);
    }
    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
            return m.call(o);
        if (o && typeof o.length === "number")
            return {
                next: function () {
                    if (o && i >= o.length)
                        o = void 0;
                    return { value: o && o[i++], done: !o };
                }
            };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }
    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    ;
    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }
    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n])
            i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try {
            step(g[n](v));
        }
        catch (e) {
            settle(q[0][3], e);
        } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]); }
    }
    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }
    function __asyncValues(o) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }
    }
    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
        }
        else {
            cooked.raw = raw;
        }
        return cooked;
    }
    ;
    var __setModuleDefault = Object.create ? (function (o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function (o, v) {
        o["default"] = v;
    };
    function __importStar(mod) {
        if (mod && mod.__esModule)
            return mod;
        var result = {};
        if (mod != null)
            for (var k in mod)
                if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                    __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    }
    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }
    function __classPrivateFieldGet(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
    }
    function __classPrivateFieldSet(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
    }

    (function (STYLE) {
        STYLE["TINY"] = "tiny";
        STYLE["BIG"] = "big";
        STYLE["NORMAL"] = "normal";
    })(exports.STYLE || (exports.STYLE = {}));
    (function (THEME) {
        THEME["LIGHT"] = "light";
        THEME["DARK"] = "dark";
    })(exports.THEME || (exports.THEME = {}));

    (function (Event) {
        Event["onPagination"] = "onPagination";
        Event["onOrder"] = "onOrder";
        Event["onGlobalSearch"] = "onGlobalSearch";
        Event["onSearch"] = "onSearch";
        Event["onClick"] = "onClick";
        Event["onDoubleClick"] = "onDoubleClick";
        Event["onCheckboxSelect"] = "onCheckboxSelect";
        Event["onRadioSelect"] = "onRadioSelect";
        Event["onCheckboxToggle"] = "onCheckboxToggle";
        Event["onSelectAll"] = "onSelectAll";
        Event["onInfiniteScrollEnd"] = "onInfiniteScrollEnd";
        Event["onColumnResizeMouseDown"] = "onColumnResizeMouseDown";
        Event["onColumnResizeMouseUp"] = "onColumnResizeMouseUp";
        Event["onRowDrop"] = "onRowDrop";
        Event["onRowCollapsedShow"] = "onRowCollapsedShow";
        Event["onRowCollapsedHide"] = "onRowCollapsedHide";
        Event["onRowContextMenu"] = "onRowContextMenu";
    })(exports.Event || (exports.Event = {}));

    (function (API) {
        API["rowContextMenuClicked"] = "rowContextMenuClicked";
        API["setInputValue"] = "setInputValue";
        API["toolPanelClicked"] = "toolPanelClicked";
        API["toggleRowIndex"] = "toggleRowIndex";
        API["toggleCheckbox"] = "toggleCheckbox";
        API["onGlobalSearch"] = "onGlobalSearch";
        API["setPaginationCurrentPage"] = "setPaginationCurrentPage";
        API["getPaginationCurrentPage"] = "getPaginationCurrentPage";
        API["getPaginationTotalItems"] = "getPaginationTotalItems";
        API["getNumberOfRowsPerPage"] = "getNumberOfRowsPerPage";
        API["getPaginationLastPage"] = "getPaginationLastPage";
        API["setPaginationRange"] = "setPaginationRange";
        API["setPaginationPreviousLabel"] = "setPaginationPreviousLabel";
        API["setPaginationNextLabel"] = "setPaginationNextLabel";
        API["setPaginationDisplayLimit"] = "setPaginationDisplayLimit";
        API["setTableClass"] = "setTableClass";
        API["setRowClass"] = "setRowClass";
        API["setCellClass"] = "setCellClass";
        API["setRowStyle"] = "setRowStyle";
        API["setCellStyle"] = "setCellStyle";
        API["sortBy"] = "sortBy";
    })(exports.API || (exports.API = {}));

    // tslint:disable-next-line:variable-name
    var DefaultConfig = {
        searchEnabled: false,
        headerEnabled: true,
        orderEnabled: true,
        orderEventOnly: false,
        paginationEnabled: true,
        exportEnabled: false,
        clickEvent: true,
        selectRow: false,
        selectCol: false,
        selectCell: false,
        rows: 10,
        additionalActions: false,
        serverPagination: false,
        isLoading: false,
        detailsTemplate: false,
        groupRows: false,
        paginationRangeEnabled: true,
        collapseAllRows: false,
        checkboxes: false,
        radio: false,
        resizeColumn: false,
        fixedColumnWidth: true,
        horizontalScroll: false,
        draggable: false,
        logger: false,
        showDetailsArrow: false,
        showContextMenu: false,
        persistState: false,
        paginationMaxSize: 5,
        threeWaySort: false,
        tableLayout: {
            style: exports.STYLE.NORMAL,
            theme: exports.THEME.LIGHT,
            borderless: false,
            hover: true,
            striped: false,
        },
    };
    var DefaultConfigService = /** @class */ (function () {
        function DefaultConfigService() {
        }
        return DefaultConfigService;
    }());
    DefaultConfigService.config = DefaultConfig;
    DefaultConfigService.decorators = [
        { type: core.Injectable }
    ];

    var GroupRowsService = /** @class */ (function () {
        function GroupRowsService() {
        }
        GroupRowsService.doGroupRows = function (data, groupRowsBy) {
            var grouped = [];
            rxjs.from(data)
                .pipe(operators.groupBy(function (row) { return row[groupRowsBy]; }), operators.mergeMap(function (group) { return group.pipe(operators.reduce(function (acc, curr) { return __spread(acc, [curr]); }, [])); }))
                .subscribe(function (row) { return grouped.push(row); });
            return grouped;
        };
        return GroupRowsService;
    }());
    GroupRowsService.decorators = [
        { type: core.Injectable }
    ];

    /* tslint:disable:no-useless-cast */
    var StyleService = /** @class */ (function () {
        function StyleService() {
        }
        StyleService.prototype.setRowClass = function (val) {
            var selector = "#table > tbody > tr:nth-child(" + val.row + ")";
            var row = document.querySelector(selector);
            if (row) {
                row.classList.add(val.className);
            }
        };
        StyleService.prototype.setCellClass = function (val) {
            var selector = "#table > tbody > tr:nth-child(" + val.row + ") > td:nth-child(" + val.cell + ")";
            var cell = document.querySelector(selector);
            if (cell) {
                cell.classList.add(val.className);
            }
        };
        StyleService.prototype.setRowStyle = function (val) {
            var selector = "#table > tbody > tr:nth-child(" + val.row + ")";
            var row = document.querySelector(selector);
            if (row) {
                // tslint:disable-next-line:no-string-literal
                row.style[val.attr] = val.value;
            }
        };
        StyleService.prototype.setCellStyle = function (val) {
            var selector = "#table > tbody > tr:nth-child(" + val.row + ") > td:nth-child(" + val.cell + ")";
            var cell = document.querySelector(selector);
            if (cell) {
                // tslint:disable-next-line:no-string-literal
                cell.style[val.attr] = val.value;
            }
        };
        StyleService.prototype.pinnedWidth = function (pinned, column) {
            if (pinned) {
                return 150 * column + 'px';
            }
        };
        return StyleService;
    }());
    StyleService.decorators = [
        { type: core.Injectable }
    ];

    var BaseComponent = /** @class */ (function () {
        function BaseComponent(cdr, scrollDispatcher, styleService) {
            var _this = this;
            this.cdr = cdr;
            this.scrollDispatcher = scrollDispatcher;
            this.styleService = styleService;
            this.unsubscribe = new rxjs.Subject();
            this.filterCount = -1;
            this.filteredCountSubject = new rxjs.Subject();
            this.tableClass = null;
            this.grouped = [];
            this.isSelected = false;
            this.page = 1;
            this.count = 0;
            this.sortState = new Map();
            this.sortKey = null;
            this.rowContextMenuPosition = {
                top: null,
                left: null,
                value: null,
            };
            this.sortBy = {
                key: '',
                order: 'asc',
            };
            this.selectedDetailsTemplateRowId = new Set();
            this.selectedCheckboxes = new Set();
            this.id = 'table';
            this.event = new core.EventEmitter();
            this.filteredCountSubject.pipe(operators.takeUntil(this.unsubscribe)).subscribe(function (count) {
                setTimeout(function () {
                    _this.filterCount = count;
                    _this.cdr.detectChanges();
                });
            });
        }
        BaseComponent.prototype.onContextMenuClick = function (targetElement) {
            if (this.contextMenu && !this.contextMenu.nativeElement.contains(targetElement)) {
                this.rowContextMenuPosition = {
                    top: null,
                    left: null,
                    value: null,
                };
            }
        };
        BaseComponent.prototype.ngOnInit = function () {
            if (!this.columns) {
                console.error('[columns] property required!');
            }
            if (this.configuration) {
                this.config = this.configuration;
            }
            else {
                this.config = DefaultConfigService.config;
            }
            this.limit = this.config.rows;
            if (this.groupRowsBy) {
                this.grouped = GroupRowsService.doGroupRows(this.data, this.groupRowsBy);
            }
            this.doDecodePersistedState();
        };
        BaseComponent.prototype.ngOnDestroy = function () {
            this.unsubscribe.next();
            this.unsubscribe.complete();
        };
        BaseComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            var throttleValue = this.config.infiniteScrollThrottleTime
                ? this.config.infiniteScrollThrottleTime
                : 200;
            this.scrollDispatcher
                .scrolled()
                .pipe(operators.throttleTime(throttleValue), operators.filter(function (event) {
                return (!!event &&
                    _this.viewPort &&
                    _this.viewPort.getRenderedRange().end === _this.viewPort.getDataLength());
            }), operators.takeUntil(this.unsubscribe))
                .subscribe(function () {
                _this.emitEvent(exports.Event.onInfiniteScrollEnd, null);
            });
        };
        BaseComponent.prototype.ngOnChanges = function (changes) {
            var configuration = changes.configuration, data = changes.data, pagination = changes.pagination, groupRowsBy = changes.groupRowsBy;
            this.toggleRowIndex = changes.toggleRowIndex;
            if (configuration && configuration.currentValue) {
                this.config = configuration.currentValue;
            }
            if (data && data.currentValue) {
                this.doApplyData(data);
            }
            if (pagination && pagination.currentValue) {
                var _a = pagination.currentValue, count = _a.count, limit = _a.limit, offset = _a.offset;
                this.count = count;
                this.limit = limit;
                this.page = offset;
            }
            if (groupRowsBy && groupRowsBy.currentValue) {
                this.grouped = GroupRowsService.doGroupRows(this.data, this.groupRowsBy);
            }
            if (this.toggleRowIndex && this.toggleRowIndex.currentValue) {
                var row = this.toggleRowIndex.currentValue;
                this.collapseRow(row.index);
            }
        };
        BaseComponent.prototype.orderBy = function (column) {
            if (typeof column.orderEnabled !== 'undefined' && !column.orderEnabled) {
                return;
            }
            this.sortKey = column.key;
            if (!this.config.orderEnabled || this.sortKey === '') {
                return;
            }
            this.setColumnOrder(this.sortKey);
            if (!this.config.orderEventOnly && !column.orderEventOnly) {
                this.sortBy.key = this.sortKey;
                this.sortBy.order = this.sortState.get(this.sortKey);
            }
            else {
                this.sortBy.key = '';
                this.sortBy.order = '';
            }
            if (!this.config.serverPagination) {
                this.data = __spread(this.data);
                this.sortBy = Object.assign({}, this.sortBy);
            }
            var value = {
                key: this.sortKey,
                order: this.sortState.get(this.sortKey),
            };
            this.emitEvent(exports.Event.onOrder, value);
        };
        BaseComponent.prototype.onClick = function ($event, row, key, colIndex, rowIndex) {
            if (this.config.selectRow) {
                this.selectedRow = rowIndex;
            }
            if (this.config.selectCol && colIndex) {
                this.selectedCol = colIndex;
            }
            if (this.config.selectCell && colIndex) {
                this.selectedRow = rowIndex;
                this.selectedCol = colIndex;
            }
            if (this.config.clickEvent) {
                var value = {
                    event: $event,
                    row: row,
                    key: key,
                    rowId: rowIndex,
                    colId: colIndex,
                };
                this.emitEvent(exports.Event.onClick, value);
            }
        };
        BaseComponent.prototype.onDoubleClick = function ($event, row, key, colIndex, rowIndex) {
            var value = {
                event: $event,
                row: row,
                key: key,
                rowId: rowIndex,
                colId: colIndex,
            };
            this.emitEvent(exports.Event.onDoubleClick, value);
        };
        BaseComponent.prototype.onCheckboxSelect = function ($event, row, rowIndex) {
            var value = {
                event: $event,
                row: row,
                rowId: rowIndex,
            };
            this.emitEvent(exports.Event.onCheckboxSelect, value);
        };
        BaseComponent.prototype.onRadioSelect = function ($event, row, rowIndex) {
            var value = {
                event: $event,
                row: row,
                rowId: rowIndex,
            };
            this.emitEvent(exports.Event.onRadioSelect, value);
        };
        BaseComponent.prototype.onSelectAll = function () {
            this.isSelected = !this.isSelected;
            this.emitEvent(exports.Event.onSelectAll, this.isSelected);
        };
        BaseComponent.prototype.onSearch = function ($event) {
            if (!this.config.serverPagination) {
                this.term = $event;
            }
            this.emitEvent(exports.Event.onSearch, $event);
        };
        BaseComponent.prototype.onGlobalSearch = function (value) {
            if (!this.config.serverPagination) {
                this.globalSearchTerm = value;
            }
            this.emitEvent(exports.Event.onGlobalSearch, value);
        };
        BaseComponent.prototype.onPagination = function (pagination) {
            this.page = pagination.page;
            this.limit = pagination.limit;
            this.emitEvent(exports.Event.onPagination, pagination);
        };
        BaseComponent.prototype.toggleCheckbox = function (rowIndex) {
            this.selectedCheckboxes.has(rowIndex)
                ? this.selectedCheckboxes.delete(rowIndex)
                : this.selectedCheckboxes.add(rowIndex);
        };
        BaseComponent.prototype.collapseRow = function (rowIndex) {
            if (this.selectedDetailsTemplateRowId.has(rowIndex)) {
                this.selectedDetailsTemplateRowId.delete(rowIndex);
                this.emitEvent(exports.Event.onRowCollapsedHide, rowIndex);
            }
            else {
                this.selectedDetailsTemplateRowId.add(rowIndex);
                this.emitEvent(exports.Event.onRowCollapsedShow, rowIndex);
            }
        };
        BaseComponent.prototype.doDecodePersistedState = function () {
            if (!this.config.persistState) {
                return;
            }
            var pagination = localStorage.getItem(exports.Event.onPagination);
            var sort = localStorage.getItem(exports.Event.onOrder);
            var search = localStorage.getItem(exports.Event.onSearch);
            if (pagination) {
                this.onPagination(JSON.parse(pagination));
            }
            if (sort) {
                var _a = JSON.parse(sort), key = _a.key, order = _a.order;
                this.bindApi({
                    type: exports.API.sortBy,
                    value: { column: key, order: order },
                });
            }
            if (search) {
                this.bindApi({
                    type: exports.API.setInputValue,
                    value: JSON.parse(search),
                });
            }
        };
        BaseComponent.prototype.isRowCollapsed = function (rowIndex) {
            if (this.config.collapseAllRows) {
                return true;
            }
            return this.selectedDetailsTemplateRowId.has(rowIndex);
        };
        Object.defineProperty(BaseComponent.prototype, "loadingHeight", {
            get: function () {
                var table = document.getElementById(this.id);
                if (table && table.rows && table.rows.length > 3) {
                    var searchEnabled = this.config.searchEnabled ? 1 : 0;
                    var headerEnabled = this.config.headerEnabled ? 1 : 0;
                    var borderTrHeight = 1;
                    var borderDivHeight = 2;
                    return ((table.rows.length - searchEnabled - headerEnabled) *
                        (table.rows[3].offsetHeight - borderTrHeight) -
                        borderDivHeight);
                }
                return 30;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(BaseComponent.prototype, "arrowDefinition", {
            get: function () {
                return this.config.showDetailsArrow || typeof this.config.showDetailsArrow === 'undefined';
            },
            enumerable: false,
            configurable: true
        });
        BaseComponent.prototype.onRowContextMenu = function ($event, row, key, colIndex, rowIndex) {
            if (!this.config.showContextMenu) {
                return;
            }
            $event.preventDefault();
            var value = {
                event: $event,
                row: row,
                key: key,
                rowId: rowIndex,
                colId: colIndex,
            };
            this.rowContextMenuPosition = {
                top: $event.pageY - 10 + "px",
                left: $event.pageX - 10 + "px",
                value: value,
            };
            this.emitEvent(exports.Event.onRowContextMenu, value);
        };
        BaseComponent.prototype.doApplyData = function (data) {
            var order = this.columns.find(function (c) { return !!c.orderBy; });
            if (order) {
                this.sortState.set(this.sortKey, order.orderBy === 'asc' ? 'desc' : 'asc');
                this.orderBy(order);
            }
            else {
                this.data = __spread(data.currentValue);
            }
        };
        BaseComponent.prototype.onDrop = function (event) {
            this.emitEvent(exports.Event.onRowDrop, event);
            dragDrop.moveItemInArray(this.data, event.previousIndex, event.currentIndex);
        };
        // DO NOT REMOVE. It is called from parent component. See src/app/demo/api-doc/api-doc.component.ts
        BaseComponent.prototype.apiEvent = function (event) {
            return this.bindApi(event);
        };
        // tslint:disable:no-big-function cognitive-complexity mccabe-complexity
        BaseComponent.prototype.bindApi = function (event) {
            var _this = this;
            switch (event.type) {
                case exports.API.rowContextMenuClicked:
                    this.rowContextMenuPosition = {
                        top: null,
                        left: null,
                        value: null,
                    };
                    break;
                case exports.API.toolPanelClicked:
                    // TODO
                    break;
                case exports.API.toggleRowIndex:
                    this.collapseRow(event.value);
                    break;
                case exports.API.toggleCheckbox:
                    this.toggleCheckbox(event.value);
                    break;
                case exports.API.setInputValue:
                    if (this.config.searchEnabled) {
                        event.value.forEach(function (input) {
                            var element = document.getElementById("search_" + input.key);
                            if (!element) {
                                console.error("Column '" + input.key + "' not available in the DOM. Have you misspelled a name?");
                            }
                            else {
                                element.value = input.value;
                            }
                        });
                    }
                    this.onSearch(event.value);
                    this.cdr.detectChanges();
                    break;
                case exports.API.onGlobalSearch:
                    this.onGlobalSearch(event.value);
                    this.cdr.detectChanges();
                    break;
                case exports.API.setRowClass:
                    if (Array.isArray(event.value)) {
                        event.value.forEach(function (val) { return _this.styleService.setRowClass(val); });
                        break;
                    }
                    this.styleService.setRowClass(event.value);
                    this.cdr.detectChanges();
                    break;
                case exports.API.setCellClass:
                    if (Array.isArray(event.value)) {
                        event.value.forEach(function (val) { return _this.styleService.setCellClass(val); });
                        break;
                    }
                    this.styleService.setCellClass(event.value);
                    break;
                case exports.API.setRowStyle:
                    if (Array.isArray(event.value)) {
                        event.value.forEach(function (val) { return _this.styleService.setRowStyle(val); });
                        break;
                    }
                    this.styleService.setRowStyle(event.value);
                    break;
                case exports.API.setCellStyle:
                    if (Array.isArray(event.value)) {
                        event.value.forEach(function (val) { return _this.styleService.setCellStyle(val); });
                        break;
                    }
                    this.styleService.setCellStyle(event.value);
                    break;
                case exports.API.setTableClass:
                    this.tableClass = event.value;
                    this.cdr.detectChanges();
                    break;
                case exports.API.getPaginationTotalItems:
                    return this.paginationComponent.paginationDirective.getTotalItems();
                case exports.API.getPaginationCurrentPage:
                    return this.paginationComponent.paginationDirective.getCurrent();
                case exports.API.getPaginationLastPage:
                    return this.paginationComponent.paginationDirective.getLastPage();
                case exports.API.getNumberOfRowsPerPage:
                    return this.paginationComponent.paginationDirective.isLastPage()
                        ? this.paginationComponent.paginationDirective.getTotalItems() % this.limit
                        : this.limit;
                case exports.API.setPaginationCurrentPage:
                    this.paginationComponent.paginationDirective.setCurrent(event.value);
                    break;
                case exports.API.setPaginationRange:
                    this.paginationComponent.ranges = event.value;
                    break;
                case exports.API.setPaginationPreviousLabel:
                    this.paginationComponent.previousLabel = event.value;
                    break;
                case exports.API.setPaginationNextLabel:
                    this.paginationComponent.nextLabel = event.value;
                    break;
                case exports.API.setPaginationDisplayLimit:
                    this.paginationComponent.changeLimit(event.value, true);
                    break;
                case exports.API.sortBy:
                    var column = { title: '', key: event.value.column, orderBy: event.value.order };
                    this.orderBy(column);
                    this.cdr.detectChanges();
                    break;
                default:
                    break;
            }
        };
        BaseComponent.prototype.setColumnOrder = function (key) {
            switch (this.sortState.get(key)) {
                case '':
                case undefined:
                    this.sortState.set(key, 'desc');
                    break;
                case 'asc':
                    this.config.threeWaySort ? this.sortState.set(key, '') : this.sortState.set(key, 'desc');
                    break;
                case 'desc':
                    this.sortState.set(key, 'asc');
                    break;
            }
            if (this.sortState.size > 1) {
                var temp = this.sortState.get(key);
                this.sortState.clear();
                this.sortState.set(key, temp);
            }
        };
        BaseComponent.prototype.emitEvent = function (event, value) {
            this.event.emit({ event: event, value: value });
            if (this.config.persistState) {
                localStorage.setItem(event, JSON.stringify(value));
            }
            if (this.config.logger) {
                // tslint:disable-next-line:no-console
                console.log({ event: event, value: value });
            }
        };
        return BaseComponent;
    }());
    BaseComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'ngx-table',
                    providers: [DefaultConfigService, GroupRowsService, StyleService],
                    template: "<div class=\"ngx-container\" [class.ngx-container--dark]=\"config.tableLayout.theme === 'dark'\">\n  <table\n    [id]=\"id\"\n    [ngClass]=\"tableClass === null || tableClass === '' ? 'ngx-table' : tableClass\"\n    [class.ngx-table__table--tiny]=\"config.tableLayout.style === 'tiny'\"\n    [class.ngx-table__table--normal]=\"config.tableLayout.style === 'normal'\"\n    [class.ngx-table__table--big]=\"config.tableLayout.style === 'big'\"\n    [class.ngx-table__table--borderless]=\"config.tableLayout.borderless\"\n    [class.ngx-table__table--dark]=\"config.tableLayout.theme === 'dark'\"\n    [class.ngx-table__table--hoverable]=\"config.tableLayout.hover\"\n    [class.ngx-table__table--striped]=\"config.tableLayout.striped\"\n    [class.ngx-table__horizontal-scroll]=\"config.horizontalScroll && !config.isLoading\"\n  >\n    <thead\n      [class.ngx-infinite-scroll-viewport-thead]=\"config.infiniteScroll\"\n      table-thead\n      [config]=\"config\"\n      [sortKey]=\"sortKey\"\n      [sortState]=\"sortState\"\n      [selectAllTemplate]=\"selectAllTemplate\"\n      [filtersTemplate]=\"filtersTemplate\"\n      [additionalActionsTemplate]=\"additionalActionsTemplate\"\n      [columns]=\"columns\"\n      (selectAll)=\"onSelectAll()\"\n      (filter)=\"onSearch($event)\"\n      (order)=\"orderBy($event)\"\n      (event)=\"emitEvent($event.event, $event.value)\"\n    ></thead>\n    <tbody *ngIf=\"data && !config.isLoading && !config.rowReorder\">\n      <ng-container *ngIf=\"rowTemplate\">\n        <ul\n          class=\"ngx-table__table-row-context-menu\"\n          [ngStyle]=\"{\n            position: 'absolute',\n            top: rowContextMenuPosition.top,\n            left: rowContextMenuPosition.left\n          }\"\n          *ngIf=\"rowContextMenuPosition.top\"\n        >\n          <ng-container\n            [ngTemplateOutlet]=\"rowContextMenu\"\n            [ngTemplateOutletContext]=\"{ $implicit: rowContextMenuPosition.value }\"\n          >\n          </ng-container>\n        </ul>\n        <ng-container *ngIf=\"!config.infiniteScroll\">\n          <ng-container\n            *ngFor=\"\n              let row of data\n                | sort: sortBy\n                | search: term:filteredCountSubject\n                | global: globalSearchTerm:filteredCountSubject\n                | paginate: { itemsPerPage: limit, currentPage: page, totalItems: count, id: id };\n              let rowIndex = index\n            \"\n          >\n            <tr\n              (click)=\"onClick($event, row, '', null, rowIndex)\"\n              #contextMenu\n              (contextmenu)=\"onRowContextMenu($event, row, '', null, rowIndex)\"\n              (dblclick)=\"onDoubleClick($event, row, '', null, rowIndex)\"\n              [class.ngx-table__table-row--selected]=\"\n                rowIndex === selectedRow && !config.selectCell\n              \"\n            >\n              <ng-container\n                [ngTemplateOutlet]=\"rowTemplate\"\n                [ngTemplateOutletContext]=\"{ $implicit: row, index: rowIndex }\"\n              >\n              </ng-container>\n              <td *ngIf=\"config.detailsTemplate\">\n                <span\n                  class=\"ngx-icon\"\n                  *ngIf=\"arrowDefinition\"\n                  [ngClass]=\"\n                    isRowCollapsed(rowIndex) ? 'ngx-icon-arrow-down' : 'ngx-icon-arrow-right'\n                  \"\n                  (click)=\"collapseRow(rowIndex)\"\n                >\n                </span>\n              </td>\n            </tr>\n            <tr\n              *ngIf=\"\n                (config.detailsTemplate && selectedDetailsTemplateRowId.has(rowIndex)) ||\n                config.collapseAllRows\n              \"\n            >\n              <td [attr.colspan]=\"columns.length + 1\">\n                <ng-container\n                  [ngTemplateOutlet]=\"detailsTemplate\"\n                  [ngTemplateOutletContext]=\"{ $implicit: row, index: rowIndex }\"\n                >\n                </ng-container>\n              </td>\n            </tr>\n          </ng-container>\n        </ng-container>\n        <cdk-virtual-scroll-viewport\n          itemSize=\"50\"\n          *ngIf=\"config.infiniteScroll\"\n          class=\"ngx-infinite-scroll-viewport\"\n        >\n          <ng-container\n            *cdkVirtualFor=\"\n              let row of data\n                | sort: sortBy\n                | search: term:filteredCountSubject\n                | global: globalSearchTerm:filteredCountSubject;\n              let rowIndex = index\n            \"\n          >\n            <tr\n              (click)=\"onClick($event, row, '', null, rowIndex)\"\n              #contextMenu\n              (contextmenu)=\"onRowContextMenu($event, row, '', null, rowIndex)\"\n              (dblclick)=\"onDoubleClick($event, row, '', null, rowIndex)\"\n              [class.ngx-table__table-row--selected]=\"\n                rowIndex === selectedRow && !config.selectCell\n              \"\n            >\n              <ng-container\n                [ngTemplateOutlet]=\"rowTemplate\"\n                [ngTemplateOutletContext]=\"{ $implicit: row, index: rowIndex }\"\n              >\n              </ng-container>\n              <td *ngIf=\"config.detailsTemplate\">\n                <span\n                  class=\"ngx-icon\"\n                  *ngIf=\"arrowDefinition\"\n                  [ngClass]=\"\n                    isRowCollapsed(rowIndex) ? 'ngx-icon-arrow-down' : 'ngx-icon-arrow-right'\n                  \"\n                  (click)=\"collapseRow(rowIndex)\"\n                >\n                </span>\n              </td>\n            </tr>\n            <tr\n              *ngIf=\"\n                (config.detailsTemplate && selectedDetailsTemplateRowId.has(rowIndex)) ||\n                config.collapseAllRows\n              \"\n            >\n              <td [attr.colspan]=\"columns.length + 1\">\n                <ng-container\n                  [ngTemplateOutlet]=\"detailsTemplate\"\n                  [ngTemplateOutletContext]=\"{ $implicit: row, index: rowIndex }\"\n                >\n                </ng-container>\n              </td>\n            </tr>\n          </ng-container>\n        </cdk-virtual-scroll-viewport>\n      </ng-container>\n      <ng-container *ngIf=\"!rowTemplate && !config.groupRows\">\n        <ul\n          class=\"ngx-table__table-row-context-menu\"\n          [ngStyle]=\"{\n            position: 'absolute',\n            top: rowContextMenuPosition.top,\n            left: rowContextMenuPosition.left\n          }\"\n          *ngIf=\"rowContextMenuPosition.top\"\n        >\n          <ng-container\n            [ngTemplateOutlet]=\"rowContextMenu\"\n            [ngTemplateOutletContext]=\"{ $implicit: rowContextMenuPosition.value }\"\n          >\n          </ng-container>\n        </ul>\n        <ng-container *ngIf=\"!config.infiniteScroll\">\n          <ng-container\n            *ngFor=\"\n              let row of data\n                | sort: sortBy\n                | search: term:filteredCountSubject\n                | global: globalSearchTerm:filteredCountSubject\n                | paginate: { itemsPerPage: limit, currentPage: page, totalItems: count, id: id };\n              let rowIndex = index\n            \"\n          >\n            <tr\n              [class.ngx-table__table-row--selected]=\"\n                rowIndex === selectedRow && !config.selectCell\n              \"\n            >\n              <td *ngIf=\"config.checkboxes\">\n                <label class=\"ngx-form-checkbox\">\n                  <input\n                    type=\"checkbox\"\n                    id=\"checkbox-{{ rowIndex }}\"\n                    [checked]=\"isSelected || selectedCheckboxes.has(rowIndex)\"\n                    (change)=\"onCheckboxSelect($event, row, rowIndex)\"\n                  />\n                  <em class=\"ngx-form-icon\"></em>\n                </label>\n              </td>\n              <td *ngIf=\"config.radio\">\n                <label>\n                  <input\n                    type=\"radio\"\n                    id=\"radio-{{ rowIndex }}\"\n                    name=\"radio\"\n                    (change)=\"onRadioSelect($event, row, rowIndex)\"\n                  />\n                </label>\n              </td>\n              <ng-container *ngFor=\"let column of columns; let colIndex = index\">\n                <td\n                  (click)=\"onClick($event, row, column.key, colIndex, rowIndex)\"\n                  #contextMenu\n                  (contextmenu)=\"onRowContextMenu($event, row, column.key, colIndex, rowIndex)\"\n                  (dblclick)=\"onDoubleClick($event, row, column.key, colIndex, rowIndex)\"\n                  [class.pinned-left]=\"column.pinned\"\n                  [ngClass]=\"column.cssClass ? column.cssClass.name : ''\"\n                  [style.left]=\"styleService.pinnedWidth(column.pinned, colIndex)\"\n                  [class.ngx-table__table-col--selected]=\"\n                    colIndex === selectedCol && !config.selectCell\n                  \"\n                  [class.ngx-table__table-cell--selected]=\"\n                    colIndex === selectedCol &&\n                    rowIndex === selectedRow &&\n                    !config.selectCol &&\n                    !config.selectRow\n                  \"\n                >\n                  <div *ngIf=\"!column.cellTemplate\">{{ row | render: column.key }}</div>\n                  <ng-container\n                    *ngIf=\"column.cellTemplate\"\n                    [ngTemplateOutlet]=\"column.cellTemplate\"\n                    [ngTemplateOutletContext]=\"{\n                      $implicit: row,\n                      rowIndex: rowIndex,\n                      column: column\n                    }\"\n                  >\n                  </ng-container>\n                </td>\n              </ng-container>\n              <td *ngIf=\"config.additionalActions || config.detailsTemplate\">\n                <span\n                  class=\"ngx-icon\"\n                  *ngIf=\"arrowDefinition\"\n                  [ngClass]=\"\n                    isRowCollapsed(rowIndex) ? 'ngx-icon-arrow-down' : 'ngx-icon-arrow-right'\n                  \"\n                  (click)=\"collapseRow(rowIndex)\"\n                >\n                </span>\n              </td>\n            </tr>\n            <tr\n              *ngIf=\"\n                (config.detailsTemplate && selectedDetailsTemplateRowId.has(rowIndex)) ||\n                config.collapseAllRows\n              \"\n            >\n              <td *ngIf=\"config.checkboxes || config.radio\"></td>\n              <td [attr.colspan]=\"columns.length + 1\">\n                <ng-container\n                  [ngTemplateOutlet]=\"detailsTemplate\"\n                  [ngTemplateOutletContext]=\"{ $implicit: row, index: rowIndex }\"\n                >\n                </ng-container>\n              </td>\n            </tr>\n          </ng-container>\n        </ng-container>\n        <!-- infinite scroll -->\n        <cdk-virtual-scroll-viewport\n          itemSize=\"50\"\n          *ngIf=\"config.infiniteScroll\"\n          class=\"ngx-infinite-scroll-viewport\"\n        >\n          <ng-container\n            *cdkVirtualFor=\"\n              let row of data\n                | sort: sortBy\n                | search: term:filteredCountSubject\n                | global: globalSearchTerm:filteredCountSubject;\n              let rowIndex = index\n            \"\n          >\n            <tr\n              [class.ngx-table__table-row--selected]=\"\n                rowIndex === selectedRow && !config.selectCell\n              \"\n            >\n              <td *ngIf=\"config.checkboxes\">\n                <label class=\"ngx-form-checkbox\">\n                  <input\n                    type=\"checkbox\"\n                    id=\"checkbox-infinite-scroll-{{ rowIndex }}\"\n                    [checked]=\"isSelected || selectedCheckboxes.has(rowIndex)\"\n                    (change)=\"onCheckboxSelect($event, row, rowIndex)\"\n                  />\n                  <em class=\"ngx-form-icon\"></em>\n                </label>\n              </td>\n              <td *ngIf=\"config.radio\">\n                <label>\n                  <input\n                    type=\"radio\"\n                    id=\"radio-infinite-scroll-{{ rowIndex }}\"\n                    name=\"radio\"\n                    (change)=\"onRadioSelect($event, row, rowIndex)\"\n                  />\n                </label>\n              </td>\n              <ng-container *ngFor=\"let column of columns; let colIndex = index\">\n                <td\n                  (click)=\"onClick($event, row, column.key, colIndex, rowIndex)\"\n                  #contextMenu\n                  (contextmenu)=\"onRowContextMenu($event, row, column.key, colIndex, rowIndex)\"\n                  (dblclick)=\"onDoubleClick($event, row, column.key, colIndex, rowIndex)\"\n                  [class.pinned-left]=\"column.pinned\"\n                  [ngClass]=\"column.cssClass ? column.cssClass.name : ''\"\n                  [style.left]=\"styleService.pinnedWidth(column.pinned, colIndex)\"\n                  [class.ngx-table__table-col--selected]=\"\n                    colIndex === selectedCol && !config.selectCell\n                  \"\n                  [class.ngx-table__table-cell--selected]=\"\n                    colIndex === selectedCol &&\n                    rowIndex === selectedRow &&\n                    !config.selectCol &&\n                    !config.selectRow\n                  \"\n                >\n                  <div *ngIf=\"!column.cellTemplate\">{{ row | render: column.key }}</div>\n                  <ng-container\n                    *ngIf=\"column.cellTemplate\"\n                    [ngTemplateOutlet]=\"column.cellTemplate\"\n                    [ngTemplateOutletContext]=\"{\n                      $implicit: row,\n                      rowIndex: rowIndex,\n                      column: column\n                    }\"\n                  >\n                  </ng-container>\n                </td>\n              </ng-container>\n              <td *ngIf=\"config.additionalActions || config.detailsTemplate\">\n                <span\n                  class=\"ngx-icon\"\n                  *ngIf=\"arrowDefinition\"\n                  [ngClass]=\"\n                    isRowCollapsed(rowIndex) ? 'ngx-icon-arrow-down' : 'ngx-icon-arrow-right'\n                  \"\n                  (click)=\"collapseRow(rowIndex)\"\n                >\n                </span>\n              </td>\n            </tr>\n            <tr\n              *ngIf=\"\n                (config.detailsTemplate && selectedDetailsTemplateRowId.has(rowIndex)) ||\n                config.collapseAllRows\n              \"\n            >\n              <td *ngIf=\"config.checkboxes || config.radio\"></td>\n              <td [attr.colspan]=\"columns.length + 1\">\n                <ng-container\n                  [ngTemplateOutlet]=\"detailsTemplate\"\n                  [ngTemplateOutletContext]=\"{ $implicit: row, index: rowIndex }\"\n                >\n                </ng-container>\n              </td>\n            </tr>\n          </ng-container>\n        </cdk-virtual-scroll-viewport>\n      </ng-container>\n      <ng-container *ngIf=\"!rowTemplate && config.groupRows\">\n        <ng-container\n          *ngFor=\"\n            let group of grouped\n              | sort: sortBy:config\n              | search: term:filteredCountSubject:config\n              | global: globalSearchTerm:filteredCountSubject\n              | paginate: { itemsPerPage: limit, currentPage: page, totalItems: count, id: id };\n            let rowIndex = index\n          \"\n        >\n          <tr>\n            <ng-container *ngIf=\"!groupRowsHeaderTemplate\">\n              <td [attr.colspan]=\"columns.length\">\n                <div>{{ group[0][groupRowsBy] }} ({{ group.length }})</div>\n              </td>\n            </ng-container>\n            <ng-container\n              *ngIf=\"groupRowsHeaderTemplate\"\n              [ngTemplateOutlet]=\"groupRowsHeaderTemplate\"\n              [ngTemplateOutletContext]=\"{\n                total: group.length,\n                key: groupRowsBy,\n                value: group[0] ? group[0][groupRowsBy] : '',\n                group: group,\n                index: rowIndex\n              }\"\n            >\n            </ng-container>\n            <td>\n              <span\n                class=\"ngx-icon\"\n                *ngIf=\"arrowDefinition\"\n                [ngClass]=\"\n                  isRowCollapsed(rowIndex) ? 'ngx-icon-arrow-down' : 'ngx-icon-arrow-right'\n                \"\n                (click)=\"collapseRow(rowIndex)\"\n              >\n              </span>\n            </td>\n          </tr>\n          <ng-container *ngIf=\"selectedDetailsTemplateRowId.has(rowIndex)\">\n            <tr *ngFor=\"let row of group\">\n              <td *ngFor=\"let column of columns\">\n                {{ row | render: column.key }}\n                <!-- TODO allow users to add groupRowsTemplateRef -->\n              </td>\n              <td></td>\n            </tr>\n          </ng-container>\n        </ng-container>\n      </ng-container>\n    </tbody>\n    <tbody\n      *ngIf=\"data && !config.isLoading && config.rowReorder\"\n      class=\"ngx-draggable-row-area\"\n      cdkDropList\n      (cdkDropListDropped)=\"onDrop($event)\"\n    >\n      <ng-container *ngIf=\"!rowTemplate && !config.groupRows\">\n        <ng-container\n          *ngFor=\"\n            let row of data\n              | sort: sortBy\n              | search: term:filteredCountSubject\n              | global: globalSearchTerm:filteredCountSubject\n              | paginate: { itemsPerPage: limit, currentPage: page, totalItems: count, id: id };\n            let rowIndex = index\n          \"\n        >\n          <tr class=\"ngx-draggable-row\" cdkDrag cdkDragLockAxis=\"y\">\n            <td *ngIf=\"config.checkboxes\">\n              <label class=\"ngx-form-checkbox\">\n                <input\n                  type=\"checkbox\"\n                  id=\"checkbox-draggable-{{ rowIndex }}\"\n                  [checked]=\"isSelected || selectedCheckboxes.has(rowIndex)\"\n                  (change)=\"onCheckboxSelect($event, row, rowIndex)\"\n                />\n                <em class=\"ngx-form-icon\"></em>\n              </label>\n            </td>\n            <td *ngIf=\"config.radio\">\n              <label>\n                <input\n                  type=\"radio\"\n                  id=\"radio-draggable-{{ rowIndex }}\"\n                  name=\"radio\"\n                  (change)=\"onRadioSelect($event, row, rowIndex)\"\n                />\n              </label>\n            </td>\n            <ng-container *ngFor=\"let column of columns; let colIndex = index\">\n              <td\n                (click)=\"onClick($event, row, column.key, colIndex, rowIndex)\"\n                (dblclick)=\"onDoubleClick($event, row, column.key, colIndex, rowIndex)\"\n                [class.ngx-table__table-col--selected]=\"\n                  colIndex === selectedCol && !config.selectCell\n                \"\n                [class.ngx-table__table-cell--selected]=\"\n                  colIndex === selectedCol &&\n                  rowIndex === selectedRow &&\n                  !config.selectCol &&\n                  !config.selectRow\n                \"\n              >\n                <div *ngIf=\"!column.cellTemplate\">{{ row | render: column.key }}</div>\n                <ng-container\n                  *ngIf=\"column.cellTemplate\"\n                  [ngTemplateOutlet]=\"column.cellTemplate\"\n                  [ngTemplateOutletContext]=\"{\n                    $implicit: row,\n                    rowIndex: rowIndex,\n                    column: column\n                  }\"\n                >\n                </ng-container>\n              </td>\n            </ng-container>\n          </tr>\n        </ng-container>\n      </ng-container>\n    </tbody>\n    <tbody *ngIf=\"filterCount === 0\">\n      <tr class=\"ngx-table__body-empty\">\n        <ng-container *ngIf=\"noResultsTemplate\" [ngTemplateOutlet]=\"noResultsTemplate\">\n        </ng-container>\n        <td [attr.colspan]=\"columns && columns.length + 1\" *ngIf=\"!noResultsTemplate\">\n          <div class=\"ngx-table__table-no-results\">No results</div>\n        </td>\n      </tr>\n    </tbody>\n    <tbody *ngIf=\"config.isLoading\">\n      <tr class=\"ngx-table__body-loading\">\n        <ng-container *ngIf=\"loadingTemplate\" [ngTemplateOutlet]=\"loadingTemplate\"> </ng-container>\n        <td [attr.colspan]=\"columns && columns.length + 1\" *ngIf=\"!loadingTemplate\">\n          <div [style.height.px]=\"loadingHeight\" class=\"ngx-table__table-loader-wrapper\">\n            <div class=\"ngx-table__table-loader\"></div>\n          </div>\n        </td>\n      </tr>\n    </tbody>\n    <tfoot *ngIf=\"summaryTemplate\">\n      <tr>\n        <ng-container\n          [ngTemplateOutlet]=\"summaryTemplate\"\n          [ngTemplateOutletContext]=\"{ total: data.length, limit: limit, page: page }\"\n        >\n        </ng-container>\n      </tr>\n    </tfoot>\n  </table>\n  <pagination\n    [attr.id]=\"'pagination' + id\"\n    [id]=\"id\"\n    #paginationComponent\n    [config]=\"config\"\n    [pagination]=\"pagination\"\n    (updateRange)=\"onPagination($event)\"\n  >\n  </pagination>\n</div>\n",
                    changeDetection: core.ChangeDetectionStrategy.OnPush
                },] }
    ];
    BaseComponent.ctorParameters = function () { return [
        { type: core.ChangeDetectorRef },
        { type: scrolling.ScrollDispatcher },
        { type: StyleService }
    ]; };
    BaseComponent.propDecorators = {
        configuration: [{ type: core.Input }],
        data: [{ type: core.Input }],
        pagination: [{ type: core.Input }],
        groupRowsBy: [{ type: core.Input }],
        id: [{ type: core.Input }],
        toggleRowIndex: [{ type: core.Input }],
        detailsTemplate: [{ type: core.Input }],
        summaryTemplate: [{ type: core.Input }],
        groupRowsHeaderTemplate: [{ type: core.Input }],
        filtersTemplate: [{ type: core.Input }],
        selectAllTemplate: [{ type: core.Input }],
        noResultsTemplate: [{ type: core.Input }],
        loadingTemplate: [{ type: core.Input }],
        additionalActionsTemplate: [{ type: core.Input }],
        rowContextMenu: [{ type: core.Input }],
        columns: [{ type: core.Input }],
        event: [{ type: core.Output }],
        rowTemplate: [{ type: core.ContentChild, args: [core.TemplateRef, { static: true },] }],
        paginationComponent: [{ type: core.ViewChild, args: ['paginationComponent',] }],
        contextMenu: [{ type: core.ViewChild, args: ['contextMenu',] }],
        viewPort: [{ type: core.ViewChild, args: [scrolling.CdkVirtualScrollViewport,] }],
        onContextMenuClick: [{ type: core.HostListener, args: ['document:click', ['$event.target'],] }]
    };

    var HeaderComponent = /** @class */ (function () {
        function HeaderComponent() {
            this.update = new core.EventEmitter();
        }
        HeaderComponent.prototype.unifyKey = function (key) {
            return key.replace('.', '_');
        };
        HeaderComponent.prototype.onSearch = function (input) {
            this.update.emit([{ value: input.value, key: this.column.key }]);
        };
        return HeaderComponent;
    }());
    HeaderComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'table-header',
                    template: "<label for=\"search_{{ unifyKey(column.key) }}\">\n  <input\n    type=\"text\"\n    id=\"search_{{ unifyKey(column.key) }}\"\n    aria-label=\"Search\"\n    placeholder=\"{{ column.placeholder ? column.placeholder : column.title }}\"\n    class=\"ngx-table__header-search\"\n    #input\n    (input)=\"onSearch(input)\"\n  />\n</label>\n",
                    changeDetection: core.ChangeDetectionStrategy.OnPush
                },] }
    ];
    HeaderComponent.propDecorators = {
        column: [{ type: core.Input }],
        update: [{ type: core.Output }]
    };

    var PaginationComponent = /** @class */ (function () {
        function PaginationComponent() {
            this.updateRange = new core.EventEmitter();
            this.ranges = [5, 10, 25, 50, 100];
            this.showRange = false;
            this.screenReaderPaginationLabel = 'Pagination';
            this.screenReaderPageLabel = 'page';
            this.screenReaderCurrentLabel = 'You are on page';
            this.previousLabel = '';
            this.nextLabel = '';
            this.directionLinks = true;
        }
        PaginationComponent.prototype.onClick = function (targetElement) {
            if (this.paginationRange && !this.paginationRange.nativeElement.contains(targetElement)) {
                this.showRange = false;
            }
        };
        PaginationComponent.prototype.ngOnChanges = function (changes) {
            var config = changes.config;
            if (config && config.currentValue) {
                this.selectedLimit = this.config.rows;
            }
        };
        PaginationComponent.prototype.onPageChange = function (page) {
            this.updateRange.emit({
                page: page,
                limit: this.selectedLimit,
            });
        };
        PaginationComponent.prototype.changeLimit = function (limit, callFromAPI) {
            if (!callFromAPI) {
                this.showRange = !this.showRange;
            }
            this.selectedLimit = limit;
            this.updateRange.emit({
                page: 1,
                limit: limit,
            });
        };
        return PaginationComponent;
    }());
    PaginationComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'pagination',
                    template: "<div\n  class=\"ngx-pagination-wrapper\"\n  [style.display]=\"config.paginationEnabled ? '' : 'none'\"\n  [class.ngx-table__table--dark-pagination-wrapper]=\"config.tableLayout.theme === 'dark'\"\n>\n  <div class=\"ngx-pagination-steps\">\n    <pagination-template\n      #paginationDirective=\"paginationApi\"\n      id=\"pagination-controls\"\n      [id]=\"id\"\n      [class.ngx-table__table--dark-pagination]=\"config.tableLayout.theme === 'dark'\"\n      [maxSize]=\"config.paginationMaxSize || 5\"\n      (pageChange)=\"onPageChange($event)\"\n    >\n      <ul\n        class=\"ngx-pagination\"\n        role=\"navigation\"\n        [attr.aria-label]=\"screenReaderPaginationLabel\"\n        [class.responsive]=\"true\"\n      >\n        <li\n          class=\"pagination-previous\"\n          [class.disabled]=\"paginationDirective.isFirstPage()\"\n          *ngIf=\"directionLinks\"\n        >\n          <a\n            tabindex=\"0\"\n            *ngIf=\"1 < paginationDirective.getCurrent()\"\n            (keyup.enter)=\"paginationDirective.previous()\"\n            (click)=\"paginationDirective.previous()\"\n            [attr.aria-label]=\"previousLabel + ' ' + screenReaderPageLabel\"\n          >\n            {{ previousLabel }} <span class=\"show-for-sr\">{{ screenReaderPageLabel }}</span>\n          </a>\n          <span *ngIf=\"paginationDirective.isFirstPage()\">\n            {{ previousLabel }} <span class=\"show-for-sr\">{{ screenReaderPageLabel }}</span>\n          </span>\n        </li>\n        <li class=\"small-screen\">\n          {{ paginationDirective.getCurrent() }} / {{ paginationDirective.getLastPage() }}\n        </li>\n        <li\n          [class.current]=\"paginationDirective.getCurrent() === page.value\"\n          [class.ellipsis]=\"page.label === '...'\"\n          *ngFor=\"let page of paginationDirective.pages\"\n        >\n          <a\n            tabindex=\"0\"\n            (keyup.enter)=\"paginationDirective.setCurrent(page.value)\"\n            (click)=\"paginationDirective.setCurrent(page.value)\"\n            *ngIf=\"paginationDirective.getCurrent() !== page.value\"\n          >\n            <span class=\"show-for-sr\">{{ screenReaderPageLabel }} </span>\n            <span>{{ page.label }}</span>\n          </a>\n          <ng-container *ngIf=\"paginationDirective.getCurrent() === page.value\">\n            <span class=\"show-for-sr\">{{ screenReaderCurrentLabel }} </span>\n            <span>{{ page.label }}</span>\n          </ng-container>\n        </li>\n        <li\n          class=\"pagination-next\"\n          [class.disabled]=\"paginationDirective.isLastPage()\"\n          *ngIf=\"directionLinks\"\n        >\n          <a\n            tabindex=\"0\"\n            *ngIf=\"!paginationDirective.isLastPage()\"\n            (keyup.enter)=\"paginationDirective.next()\"\n            (click)=\"paginationDirective.next()\"\n            [attr.aria-label]=\"nextLabel + ' ' + screenReaderPageLabel\"\n          >\n            {{ nextLabel }} <span class=\"show-for-sr\">{{ screenReaderPageLabel }}</span>\n          </a>\n          <span *ngIf=\"paginationDirective.isLastPage()\">\n            {{ nextLabel }} <span class=\"show-for-sr\">{{ screenReaderPageLabel }}</span>\n          </span>\n        </li>\n      </ul>\n    </pagination-template>\n  </div>\n  <div\n    class=\"ngx-pagination-range\"\n    #paginationRange\n    [class.ngx-table__table--dark-pagination-range]=\"config.tableLayout.theme === 'dark'\"\n    *ngIf=\"config.paginationRangeEnabled\"\n  >\n    <div class=\"ngx-dropdown ngx-pagination-range-dropdown\" id=\"rowAmount\">\n      <div class=\"ngx-btn-group\">\n        <div class=\"ngx-pagination-range-dropdown-button\" (click)=\"showRange = !showRange\">\n          {{selectedLimit}} <i class=\"ngx-icon ngx-icon-arrow-down\"></i>\n        </div>\n        <ul class=\"ngx-menu\" *ngIf=\"showRange\">\n          <li\n            class=\"ngx-pagination-range-dropdown-button-item\"\n            [class.ngx-pagination-range--selected]=\"limit === selectedLimit\"\n            (click)=\"changeLimit(limit, false)\"\n            *ngFor=\"let limit of ranges\"\n          >\n            <span>{{limit}}</span>\n          </li>\n        </ul>\n      </div>\n    </div>\n  </div>\n</div>\n",
                    changeDetection: core.ChangeDetectionStrategy.OnPush
                },] }
    ];
    PaginationComponent.propDecorators = {
        paginationDirective: [{ type: core.ViewChild, args: ['paginationDirective', { static: true },] }],
        paginationRange: [{ type: core.ViewChild, args: ['paginationRange',] }],
        pagination: [{ type: core.Input }],
        config: [{ type: core.Input }],
        id: [{ type: core.Input }],
        updateRange: [{ type: core.Output }],
        onClick: [{ type: core.HostListener, args: ['document:click', ['$event.target'],] }]
    };

    var GlobalSearchPipe = /** @class */ (function () {
        function GlobalSearchPipe() {
        }
        GlobalSearchPipe.prototype.transform = function (array, filter, filteredCountSubject) {
            filteredCountSubject.next(0);
            if (typeof array === 'undefined') {
                return;
            }
            if (typeof filter === 'undefined' || Object.keys(filter).length === 0 || filter === '') {
                filteredCountSubject.next(array.length);
                return array;
            }
            var arr = array.filter(function (row) {
                var element = JSON.stringify(Object.values(row));
                var strings = filter.split(',');
                return strings.some(function (string) { return element.toLocaleLowerCase().indexOf(string.trim().toLocaleLowerCase()) > -1; });
            });
            filteredCountSubject.next(arr.length);
            return arr;
        };
        return GlobalSearchPipe;
    }());
    GlobalSearchPipe.decorators = [
        { type: core.Pipe, args: [{
                    name: 'global',
                },] }
    ];

    var FiltersService = /** @class */ (function () {
        function FiltersService() {
        }
        FiltersService.getPath = function (p, o) {
            // https://github.com/dherges/ng-packagr/issues/696
            /* tslint:disable-next-line */
            var result = p.reduce(function (xs, x) { return (xs && typeof xs[x] !== 'undefined' ? xs[x] : null); }, o);
            return result;
        };
        return FiltersService;
    }());
    FiltersService.decorators = [
        { type: core.Injectable }
    ];

    var RenderPipe = /** @class */ (function () {
        function RenderPipe() {
        }
        RenderPipe.prototype.transform = function (row, key) {
            var split = key.split('.');
            return FiltersService.getPath(split, row);
        };
        return RenderPipe;
    }());
    RenderPipe.decorators = [
        { type: core.Pipe, args: [{
                    name: 'render',
                },] }
    ];

    var SearchPipe = /** @class */ (function () {
        function SearchPipe() {
            this.filters = {};
        }
        SearchPipe.prototype.transform = function (array, filter, filteredCountSubject, config) {
            var _this = this;
            filteredCountSubject.next(0);
            if (typeof array === 'undefined') {
                return;
            }
            if (typeof filter === 'undefined') {
                filteredCountSubject.next(array.length);
                return array;
            }
            filter.forEach(function (f) {
                _this.filters[f.key] = f.value.toString().toLocaleLowerCase();
                if (Object.keys(f).length === 0 || f.value === '') {
                    // tslint:disable-next-line:no-dynamic-delete
                    delete _this.filters[f.key];
                }
            });
            if (config && config.groupRows) {
                return array.map(function (arr) { return _this.filterGroup(arr, filteredCountSubject); });
            }
            return this.filterGroup(array, filteredCountSubject);
        };
        SearchPipe.prototype.filterGroup = function (array, filteredCountSubject) {
            var _this = this;
            var arr = array.filter(function (obj) {
                return Object.keys(_this.filters).every(function (c) {
                    var split = c.split('.');
                    var val = FiltersService.getPath(split, obj);
                    var element = typeof val === 'object' ? JSON.stringify(val) : val.toString().toLocaleLowerCase();
                    var strings = _this.filters[c].split(',');
                    return strings.some(function (string) { return element.indexOf(string.trim()) > -1; });
                });
            });
            filteredCountSubject.next(arr.length);
            return arr;
        };
        return SearchPipe;
    }());
    SearchPipe.decorators = [
        { type: core.Pipe, args: [{
                    name: 'search',
                },] }
    ];

    var SortPipe = /** @class */ (function () {
        function SortPipe() {
            this.defaultArray = [];
        }
        SortPipe.isNaN = function (aV, bV) {
            return isNaN(parseFloat(aV)) || !isFinite(aV) || isNaN(parseFloat(bV)) || !isFinite(bV);
        };
        SortPipe.compare = function (a, b, key) {
            var split = key.split('.');
            var aPath = FiltersService.getPath(split, a);
            var bPath = FiltersService.getPath(split, b);
            var aValue = (aPath + '').toLowerCase();
            var bValue = (bPath + '').toLowerCase();
            if (SortPipe.isNaN(aPath, bPath)) {
                return aValue.localeCompare(bValue);
            }
            if (parseFloat(aPath) < parseFloat(bPath)) {
                return -1;
            }
            if (parseFloat(aPath) > parseFloat(bPath)) {
                return 1;
            }
            return 0;
        };
        SortPipe.prototype.transform = function (array, filter, config) {
            if (this.defaultArray.length === 0) {
                this.defaultArray = array;
            }
            if (!filter.key || filter.key === '') {
                return array;
            }
            if (filter.order === '') {
                return this.defaultArray;
            }
            if (filter.order === 'asc') {
                return this.sortAsc(array, filter, config);
            }
            return this.sortDesc(array, filter, config);
        };
        SortPipe.prototype.sortAsc = function (array, filter, config) {
            if (config && config.groupRows) {
                return array.map(function (arr) { return arr.sort(function (a, b) { return SortPipe.compare(a, b, filter.key); }); });
            }
            return array.sort(function (a, b) { return SortPipe.compare(a, b, filter.key); });
        };
        SortPipe.prototype.sortDesc = function (array, filter, config) {
            if (config && config.groupRows) {
                return array.map(function (arr) { return arr.sort(function (a, b) { return SortPipe.compare(b, a, filter.key); }); });
            }
            return array.sort(function (a, b) { return SortPipe.compare(b, a, filter.key); });
        };
        return SortPipe;
    }());
    SortPipe.decorators = [
        { type: core.Pipe, args: [{
                    name: 'sort',
                },] }
    ];

    var TableTHeadComponent = /** @class */ (function () {
        function TableTHeadComponent(styleService) {
            this.styleService = styleService;
            this.menuActive = false;
            this.openedHeaderActionTemplate = null;
            this.onSelectAllBinded = this.onSelectAll.bind(this);
            this.filter = new core.EventEmitter();
            this.order = new core.EventEmitter();
            this.selectAll = new core.EventEmitter();
            this.event = new core.EventEmitter();
        }
        TableTHeadComponent.prototype.onClick = function (targetElement) {
            if (this.additionalActionMenu &&
                !this.additionalActionMenu.nativeElement.contains(targetElement)) {
                this.menuActive = false;
            }
        };
        TableTHeadComponent.prototype.getColumnDefinition = function (column) {
            return column.searchEnabled || typeof column.searchEnabled === 'undefined';
        };
        TableTHeadComponent.prototype.orderBy = function (column) {
            this.order.emit(column);
        };
        TableTHeadComponent.prototype.isOrderEnabled = function (column) {
            var columnOrderEnabled = column.orderEnabled === undefined ? true : !!column.orderEnabled;
            return this.config.orderEnabled && columnOrderEnabled;
        };
        TableTHeadComponent.prototype.columnDrop = function (event) {
            dragDrop.moveItemInArray(this.columns, event.previousIndex, event.currentIndex);
        };
        TableTHeadComponent.prototype.onSearch = function ($event) {
            this.filter.emit($event);
        };
        TableTHeadComponent.prototype.getColumnWidth = function (column) {
            if (column.width) {
                return column.width;
            }
            return this.config.fixedColumnWidth ? 100 / this.columns.length + '%' : null;
        };
        TableTHeadComponent.prototype.onSelectAll = function () {
            this.selectAll.emit();
        };
        TableTHeadComponent.prototype.onMouseDown = function (event, th) {
            if (!this.config.resizeColumn) {
                return;
            }
            this.th = th;
            this.startOffset = th.offsetWidth - event.pageX;
            this.event.emit({
                event: exports.Event.onColumnResizeMouseDown,
                value: event,
            });
        };
        TableTHeadComponent.prototype.onMouseMove = function (event) {
            if (!this.config.resizeColumn) {
                return;
            }
            if (this.th && this.th.style) {
                this.th.style.width = this.startOffset + event.pageX + 'px';
                this.th.style.cursor = 'col-resize';
                this.th.style['user-select'] = 'none';
            }
        };
        TableTHeadComponent.prototype.onMouseUp = function (event) {
            if (!this.config.resizeColumn) {
                return;
            }
            this.event.emit({
                event: exports.Event.onColumnResizeMouseUp,
                value: event,
            });
            this.th.style.cursor = 'default';
            this.th = undefined;
        };
        TableTHeadComponent.prototype.showHeaderActionTemplateMenu = function (column) {
            if (!column.headerActionTemplate) {
                console.error('Column [headerActionTemplate] property not defined');
            }
            if (this.openedHeaderActionTemplate === column.key) {
                this.openedHeaderActionTemplate = null;
                return;
            }
            this.openedHeaderActionTemplate = column.key;
        };
        TableTHeadComponent.prototype.showMenu = function () {
            if (!this.additionalActionsTemplate) {
                console.error('[additionalActionsTemplate] property not defined');
            }
            this.menuActive = !this.menuActive;
        };
        return TableTHeadComponent;
    }());
    TableTHeadComponent.decorators = [
        { type: core.Component, args: [{
                    selector: '[table-thead]',
                    template: "<tr class=\"ngx-table__header\" *ngIf=\"config.headerEnabled && !config.columnReorder\">\n  <th *ngIf=\"config.checkboxes || config.radio\" [style.width]=\"'3%'\">\n    <ng-container\n      *ngIf=\"selectAllTemplate && config.checkboxes\"\n      [ngTemplateOutlet]=\"selectAllTemplate\"\n      [ngTemplateOutletContext]=\"{ $implicit: onSelectAllBinded }\"\n    >\n    </ng-container>\n    <label\n      class=\"ngx-form-checkbox\"\n      for=\"selectAllCheckboxes\"\n      *ngIf=\"!selectAllTemplate && config.checkboxes\"\n    >\n      <input type=\"checkbox\" id=\"selectAllCheckboxes\" (change)=\"onSelectAll()\" />\n      <em class=\"ngx-form-icon\" id=\"selectAllCheckbox\"></em>\n    </label>\n  </th>\n  <ng-container *ngFor=\"let column of columns; let colIndex = index; let last = last\">\n    <th\n      class=\"ngx-table__header-cell\"\n      [class.pinned-left]=\"column.pinned\"\n      [ngClass]=\"column.cssClass && column.cssClass.includeHeader ? column.cssClass.name : ''\"\n      [style.left]=\"styleService.pinnedWidth(column.pinned, colIndex)\"\n      #th\n      [style.width]=\"getColumnWidth(column)\"\n      (mousedown)=\"onMouseDown($event, th)\"\n      (mouseup)=\"onMouseUp($event)\"\n      (mousemove)=\"onMouseMove($event)\"\n    >\n      <div\n        (click)=\"orderBy(column)\"\n        style=\"display: inline\"\n        [class.pointer]=\"isOrderEnabled(column)\"\n      >\n        <div class=\"ngx-table__header-title\">\n          {{ column.title }}<span>&nbsp;</span>\n          <em class=\"ngx-icon ngx-icon-pin\" *ngIf=\"column.pinned\"></em>\n          <div [style.display]=\"config.orderEnabled ? 'inline' : 'none'\">\n            <em\n              *ngIf=\"sortKey === column.key && this.sortState.get(sortKey) === 'asc'\"\n              class=\"ngx-icon ngx-icon-arrow-up\"\n            >\n            </em>\n            <em\n              *ngIf=\"sortKey === column.key && this.sortState.get(sortKey) === 'desc'\"\n              class=\"ngx-icon ngx-icon-arrow-down\"\n            >\n            </em>\n          </div>\n        </div>\n      </div>\n      <div class=\"ngx-dropdown\" *ngIf=\"!!column.headerActionTemplate\">\n        <a class=\"ngx-btn ngx-btn-link\" (click)=\"showHeaderActionTemplateMenu(column)\">\n          <span class=\"ngx-icon ngx-icon-more\"></span>\n        </a>\n        <div\n          class=\"ngx-menu ngx-table__table-menu\"\n          *ngIf=\"column.key === openedHeaderActionTemplate\"\n        >\n          <ng-container [ngTemplateOutlet]=\"column.headerActionTemplate\"> </ng-container>\n        </div>\n      </div>\n      <div class=\"ngx-table__column-resizer\" *ngIf=\"config.resizeColumn && !last\"></div>\n    </th>\n  </ng-container>\n  <th\n    *ngIf=\"\n      config.additionalActions ||\n      config.detailsTemplate ||\n      config.collapseAllRows ||\n      config.groupRows\n    \"\n    class=\"ngx-table__header-cell-additional-actions\"\n  >\n    <div class=\"ngx-dropdown\" #additionalActionMenu *ngIf=\"config.additionalActions\">\n      <a class=\"ngx-btn ngx-btn-link\" (click)=\"showMenu()\">\n        <span class=\"ngx-icon ngx-icon-menu\"></span>\n      </a>\n      <ul class=\"ngx-menu ngx-table__table-menu\" *ngIf=\"menuActive\">\n        <ng-container\n          *ngIf=\"additionalActionsTemplate\"\n          [ngTemplateOutlet]=\"additionalActionsTemplate\"\n        >\n        </ng-container>\n      </ul>\n    </div>\n  </th>\n</tr>\n<tr\n  class=\"ngx-table__header ngx-table__header--draggable\"\n  *ngIf=\"config.headerEnabled && config.columnReorder\"\n  cdkDropList\n  cdkDropListOrientation=\"horizontal\"\n  (cdkDropListDropped)=\"columnDrop($event)\"\n>\n  <th *ngIf=\"config.checkboxes || config.radio\" [style.width]=\"'3%'\">\n    <ng-container\n      *ngIf=\"selectAllTemplate && config.checkboxes\"\n      [ngTemplateOutlet]=\"selectAllTemplate\"\n      [ngTemplateOutletContext]=\"{ $implicit: onSelectAllBinded }\"\n    >\n    </ng-container>\n    <label\n      class=\"ngx-form-checkbox\"\n      for=\"selectAllCheckboxes\"\n      *ngIf=\"!selectAllTemplate && config.checkboxes\"\n    >\n      <input type=\"checkbox\" id=\"selectAllCheckboxesDrag\" (change)=\"onSelectAll()\" />\n      <em class=\"ngx-form-icon\" id=\"selectAllCheckboxDrag\"></em>\n    </label>\n  </th>\n  <ng-container *ngFor=\"let column of columns; let colIndex = index; let last = last\">\n    <th\n      class=\"ngx-table__header-cell ngx-table__header-cell--draggable\"\n      cdkDragLockAxis=\"x\"\n      cdkDrag\n      [class.pinned-left]=\"column.pinned\"\n      [ngClass]=\"column.cssClass && column.cssClass.includeHeader ? column.cssClass.name : ''\"\n      [style.left]=\"styleService.pinnedWidth(column.pinned, colIndex)\"\n      #th\n      [style.width]=\"getColumnWidth(column)\"\n      (mousedown)=\"onMouseDown($event, th)\"\n      (mouseup)=\"onMouseUp($event)\"\n      (mousemove)=\"onMouseMove($event)\"\n    >\n      <div\n        (click)=\"orderBy(column)\"\n        style=\"display: inline\"\n        cdkDragHandle\n        [class.pointer]=\"isOrderEnabled(column)\"\n      >\n        <div class=\"ngx-table__header-title\">\n          {{ column.title }}<span>&nbsp;</span>\n          <em class=\"ngx-icon ngx-icon-pin\" *ngIf=\"column.pinned\"></em>\n          <div [style.display]=\"config.orderEnabled ? 'inline' : 'none'\">\n            <em\n              *ngIf=\"sortKey === column.key && this.sortState.get(sortKey) === 'asc'\"\n              class=\"ngx-icon ngx-icon-arrow-up\"\n            >\n            </em>\n            <em\n              *ngIf=\"sortKey === column.key && this.sortState.get(sortKey) === 'desc'\"\n              class=\"ngx-icon ngx-icon-arrow-down\"\n            >\n            </em>\n          </div>\n        </div>\n      </div>\n      <div class=\"ngx-dropdown\" *ngIf=\"!!column.headerActionTemplate\">\n        <a class=\"ngx-btn ngx-btn-link\" (click)=\"showHeaderActionTemplateMenu(column)\">\n          <span class=\"ngx-icon ngx-icon-more\"></span>\n        </a>\n        <div\n          class=\"ngx-menu ngx-table__table-menu\"\n          *ngIf=\"column.key === openedHeaderActionTemplate\"\n        >\n          <ng-container [ngTemplateOutlet]=\"column.headerActionTemplate\"> </ng-container>\n        </div>\n      </div>\n      <div class=\"ngx-table__column-resizer\" *ngIf=\"config.resizeColumn && !last\"></div>\n    </th>\n  </ng-container>\n  <th\n    *ngIf=\"\n      config.additionalActions ||\n      config.detailsTemplate ||\n      config.collapseAllRows ||\n      config.groupRows\n    \"\n    class=\"ngx-table__header-cell-additional-actions\"\n  >\n    <div class=\"ngx-dropdown\" #additionalActionMenu *ngIf=\"config.additionalActions\">\n      <a class=\"ngx-btn ngx-btn-link\" (click)=\"showMenu()\">\n        <span class=\"ngx-icon ngx-icon-menu\"></span>\n      </a>\n      <ul class=\"ngx-menu ngx-table__table-menu\" *ngIf=\"menuActive\">\n        <ng-container\n          *ngIf=\"additionalActionsTemplate\"\n          [ngTemplateOutlet]=\"additionalActionsTemplate\"\n        >\n        </ng-container>\n      </ul>\n    </div>\n  </th>\n</tr>\n<tr *ngIf=\"config.searchEnabled && !filtersTemplate\" class=\"ngx-table__sort-header\">\n  <th *ngIf=\"config.checkboxes || config.radio\"></th>\n  <ng-container *ngFor=\"let column of columns; let colIndex = index\">\n    <th\n      [ngClass]=\"column.cssClass && column.cssClass.includeHeader ? column.cssClass.name : ''\"\n      [class.pinned-left]=\"column.pinned\"\n      [style.left]=\"styleService.pinnedWidth(column.pinned, colIndex)\"\n    >\n      <table-header\n        *ngIf=\"getColumnDefinition(column)\"\n        (update)=\"onSearch($event)\"\n        [column]=\"column\"\n      >\n      </table-header>\n    </th>\n  </ng-container>\n  <th *ngIf=\"config.additionalActions || config.detailsTemplate\"></th>\n</tr>\n<ng-container *ngIf=\"filtersTemplate\">\n  <tr>\n    <ng-container [ngTemplateOutlet]=\"filtersTemplate\"> </ng-container>\n  </tr>\n</ng-container>\n",
                    changeDetection: core.ChangeDetectionStrategy.OnPush,
                    providers: [StyleService],
                    styles: ["\n      .cdk-drag-preview {\n        text-align: left;\n        padding-top: 9px;\n        padding-left: 4px;\n        color: #50596c;\n        border: 1px solid #e7e9ed;\n      }\n    "]
                },] }
    ];
    TableTHeadComponent.ctorParameters = function () { return [
        { type: StyleService }
    ]; };
    TableTHeadComponent.propDecorators = {
        config: [{ type: core.Input }],
        columns: [{ type: core.Input }],
        sortKey: [{ type: core.Input }],
        sortState: [{ type: core.Input }],
        selectAllTemplate: [{ type: core.Input }],
        filtersTemplate: [{ type: core.Input }],
        additionalActionsTemplate: [{ type: core.Input }],
        filter: [{ type: core.Output }],
        order: [{ type: core.Output }],
        selectAll: [{ type: core.Output }],
        event: [{ type: core.Output }],
        th: [{ type: core.ViewChild, args: ['th',] }],
        additionalActionMenu: [{ type: core.ViewChild, args: ['additionalActionMenu',] }],
        onClick: [{ type: core.HostListener, args: ['document:click', ['$event.target'],] }]
    };

    var BaseModule = /** @class */ (function () {
        function BaseModule() {
        }
        return BaseModule;
    }());
    BaseModule.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [
                        BaseComponent,
                        HeaderComponent,
                        PaginationComponent,
                        TableTHeadComponent,
                        // Pipes
                        SearchPipe,
                        RenderPipe,
                        GlobalSearchPipe,
                        SortPipe,
                    ],
                    imports: [common.CommonModule, ngxPagination.NgxPaginationModule, dragDrop.DragDropModule, scrolling.ScrollingModule],
                    exports: [BaseComponent],
                },] }
    ];

    var TableModule = /** @class */ (function () {
        function TableModule() {
        }
        return TableModule;
    }());
    TableModule.decorators = [
        { type: core.NgModule, args: [{
                    imports: [common.CommonModule, BaseModule],
                    exports: [BaseComponent],
                    providers: [],
                },] }
    ];

    /**
     * Generated bundle index. Do not edit.
     */

    exports.BaseComponent = BaseComponent;
    exports.DefaultConfig = DefaultConfig;
    exports.TableModule = TableModule;
    exports.a = DefaultConfigService;
    exports.b = BaseModule;
    exports.c = GroupRowsService;
    exports.d = StyleService;
    exports.e = HeaderComponent;
    exports.f = PaginationComponent;
    exports.g = TableTHeadComponent;
    exports.h = SearchPipe;
    exports.i = RenderPipe;
    exports.j = GlobalSearchPipe;
    exports.k = SortPipe;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=ngx-easy-table.umd.js.map
