!function(n,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("@angular/common"),require("@angular/core"),require("@angular/cdk/drag-drop"),require("rxjs"),require("rxjs/operators"),require("@angular/cdk/scrolling"),require("ngx-pagination")):"function"==typeof define&&define.amd?define("ngx-easy-table",["exports","@angular/common","@angular/core","@angular/cdk/drag-drop","rxjs","rxjs/operators","@angular/cdk/scrolling","ngx-pagination"],e):e((n="undefined"!=typeof globalThis?globalThis:n||self)["ngx-easy-table"]={},n.ng.common,n.ng.core,n.ng.cdk.dragDrop,n.rxjs,n.rxjs.operators,n.ng.cdk.scrolling,n.ngxPagination)}(this,(function(n,e,t,o,i,a,l,r){"use strict";
/*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */Object.create;function s(n,e){var t="function"==typeof Symbol&&n[Symbol.iterator];if(!t)return n;var o,i,a=t.call(n),l=[];try{for(;(void 0===e||e-- >0)&&!(o=a.next()).done;)l.push(o.value)}catch(n){i={error:n}}finally{try{o&&!o.done&&(t=a.return)&&t.call(a)}finally{if(i)throw i.error}}return l}function c(){for(var n=[],e=0;e<arguments.length;e++)n=n.concat(s(arguments[e]));return n}var g,d,u,p;Object.create;(g=n.STYLE||(n.STYLE={})).TINY="tiny",g.BIG="big",g.NORMAL="normal",(d=n.THEME||(n.THEME={})).LIGHT="light",d.DARK="dark",(u=n.Event||(n.Event={})).onPagination="onPagination",u.onOrder="onOrder",u.onGlobalSearch="onGlobalSearch",u.onSearch="onSearch",u.onClick="onClick",u.onDoubleClick="onDoubleClick",u.onCheckboxSelect="onCheckboxSelect",u.onRadioSelect="onRadioSelect",u.onCheckboxToggle="onCheckboxToggle",u.onSelectAll="onSelectAll",u.onInfiniteScrollEnd="onInfiniteScrollEnd",u.onColumnResizeMouseDown="onColumnResizeMouseDown",u.onColumnResizeMouseUp="onColumnResizeMouseUp",u.onRowDrop="onRowDrop",u.onRowCollapsedShow="onRowCollapsedShow",u.onRowCollapsedHide="onRowCollapsedHide",u.onRowContextMenu="onRowContextMenu",(p=n.API||(n.API={})).rowContextMenuClicked="rowContextMenuClicked",p.setInputValue="setInputValue",p.toolPanelClicked="toolPanelClicked",p.toggleRowIndex="toggleRowIndex",p.toggleCheckbox="toggleCheckbox",p.onGlobalSearch="onGlobalSearch",p.setPaginationCurrentPage="setPaginationCurrentPage",p.getPaginationCurrentPage="getPaginationCurrentPage",p.getPaginationTotalItems="getPaginationTotalItems",p.getNumberOfRowsPerPage="getNumberOfRowsPerPage",p.getPaginationLastPage="getPaginationLastPage",p.setPaginationRange="setPaginationRange",p.setPaginationPreviousLabel="setPaginationPreviousLabel",p.setPaginationNextLabel="setPaginationNextLabel",p.setPaginationDisplayLimit="setPaginationDisplayLimit",p.setTableClass="setTableClass",p.setRowClass="setRowClass",p.setCellClass="setCellClass",p.setRowStyle="setRowStyle",p.setCellStyle="setCellStyle",p.sortBy="sortBy";var h={searchEnabled:!1,headerEnabled:!0,orderEnabled:!0,orderEventOnly:!1,paginationEnabled:!0,exportEnabled:!1,clickEvent:!0,selectRow:!1,selectCol:!1,selectCell:!1,rows:10,additionalActions:!1,serverPagination:!1,isLoading:!1,detailsTemplate:!1,groupRows:!1,paginationRangeEnabled:!0,collapseAllRows:!1,checkboxes:!1,radio:!1,resizeColumn:!1,fixedColumnWidth:!0,horizontalScroll:!1,draggable:!1,logger:!1,showDetailsArrow:!1,showContextMenu:!1,persistState:!1,paginationMaxSize:5,threeWaySort:!1,tableLayout:{style:n.STYLE.NORMAL,theme:n.THEME.LIGHT,borderless:!1,hover:!0,striped:!1}},m=function(){};m.config=h,m.decorators=[{type:t.Injectable}];var f=function(){function n(){}return n.doGroupRows=function(n,e){var t=[];return i.from(n).pipe(a.groupBy((function(n){return n[e]})),a.mergeMap((function(n){return n.pipe(a.reduce((function(n,e){return c(n,[e])}),[]))}))).subscribe((function(n){return t.push(n)})),t},n}();f.decorators=[{type:t.Injectable}];var x=function(){function n(){}return n.prototype.setRowClass=function(n){var e="#table > tbody > tr:nth-child("+n.row+")",t=document.querySelector(e);t&&t.classList.add(n.className)},n.prototype.setCellClass=function(n){var e="#table > tbody > tr:nth-child("+n.row+") > td:nth-child("+n.cell+")",t=document.querySelector(e);t&&t.classList.add(n.className)},n.prototype.setRowStyle=function(n){var e="#table > tbody > tr:nth-child("+n.row+")",t=document.querySelector(e);t&&(t.style[n.attr]=n.value)},n.prototype.setCellStyle=function(n){var e="#table > tbody > tr:nth-child("+n.row+") > td:nth-child("+n.cell+")",t=document.querySelector(e);t&&(t.style[n.attr]=n.value)},n.prototype.pinnedWidth=function(n,e){if(n)return 150*e+"px"},n}();x.decorators=[{type:t.Injectable}];var b=function(){function e(n,e,o){var l=this;this.cdr=n,this.scrollDispatcher=e,this.styleService=o,this.unsubscribe=new i.Subject,this.filterCount=-1,this.filteredCountSubject=new i.Subject,this.tableClass=null,this.grouped=[],this.isSelected=!1,this.page=1,this.count=0,this.sortState=new Map,this.sortKey=null,this.rowContextMenuPosition={top:null,left:null,value:null},this.sortBy={key:"",order:"asc"},this.selectedDetailsTemplateRowId=new Set,this.selectedCheckboxes=new Set,this.id="table",this.event=new t.EventEmitter,this.filteredCountSubject.pipe(a.takeUntil(this.unsubscribe)).subscribe((function(n){setTimeout((function(){l.filterCount=n,l.cdr.detectChanges()}))}))}return e.prototype.onContextMenuClick=function(n){this.contextMenu&&!this.contextMenu.nativeElement.contains(n)&&(this.rowContextMenuPosition={top:null,left:null,value:null})},e.prototype.ngOnInit=function(){this.columns||console.error("[columns] property required!"),this.configuration?this.config=this.configuration:this.config=m.config,this.limit=this.config.rows,this.groupRowsBy&&(this.grouped=f.doGroupRows(this.data,this.groupRowsBy)),this.doDecodePersistedState()},e.prototype.ngOnDestroy=function(){this.unsubscribe.next(),this.unsubscribe.complete()},e.prototype.ngAfterViewInit=function(){var e=this,t=this.config.infiniteScrollThrottleTime?this.config.infiniteScrollThrottleTime:200;this.scrollDispatcher.scrolled().pipe(a.throttleTime(t),a.filter((function(n){return!!n&&e.viewPort&&e.viewPort.getRenderedRange().end===e.viewPort.getDataLength()})),a.takeUntil(this.unsubscribe)).subscribe((function(){e.emitEvent(n.Event.onInfiniteScrollEnd,null)}))},e.prototype.ngOnChanges=function(n){var e=n.configuration,t=n.data,o=n.pagination,i=n.groupRowsBy;if(this.toggleRowIndex=n.toggleRowIndex,e&&e.currentValue&&(this.config=e.currentValue),t&&t.currentValue&&this.doApplyData(t),o&&o.currentValue){var a=o.currentValue,l=a.count,r=a.limit,s=a.offset;this.count=l,this.limit=r,this.page=s}if(i&&i.currentValue&&(this.grouped=f.doGroupRows(this.data,this.groupRowsBy)),this.toggleRowIndex&&this.toggleRowIndex.currentValue){var c=this.toggleRowIndex.currentValue;this.collapseRow(c.index)}},e.prototype.orderBy=function(e){if((void 0===e.orderEnabled||e.orderEnabled)&&(this.sortKey=e.key,this.config.orderEnabled&&""!==this.sortKey)){this.setColumnOrder(this.sortKey),this.config.orderEventOnly||e.orderEventOnly?(this.sortBy.key="",this.sortBy.order=""):(this.sortBy.key=this.sortKey,this.sortBy.order=this.sortState.get(this.sortKey)),this.config.serverPagination||(this.data=c(this.data),this.sortBy=Object.assign({},this.sortBy));var t={key:this.sortKey,order:this.sortState.get(this.sortKey)};this.emitEvent(n.Event.onOrder,t)}},e.prototype.onClick=function(e,t,o,i,a){if(this.config.selectRow&&(this.selectedRow=a),this.config.selectCol&&i&&(this.selectedCol=i),this.config.selectCell&&i&&(this.selectedRow=a,this.selectedCol=i),this.config.clickEvent){var l={event:e,row:t,key:o,rowId:a,colId:i};this.emitEvent(n.Event.onClick,l)}},e.prototype.onDoubleClick=function(e,t,o,i,a){var l={event:e,row:t,key:o,rowId:a,colId:i};this.emitEvent(n.Event.onDoubleClick,l)},e.prototype.onCheckboxSelect=function(e,t,o){var i={event:e,row:t,rowId:o};this.emitEvent(n.Event.onCheckboxSelect,i)},e.prototype.onRadioSelect=function(e,t,o){var i={event:e,row:t,rowId:o};this.emitEvent(n.Event.onRadioSelect,i)},e.prototype.onSelectAll=function(){this.isSelected=!this.isSelected,this.emitEvent(n.Event.onSelectAll,this.isSelected)},e.prototype.onSearch=function(e){this.config.serverPagination||(this.term=e),this.emitEvent(n.Event.onSearch,e)},e.prototype.onGlobalSearch=function(e){this.config.serverPagination||(this.globalSearchTerm=e),this.emitEvent(n.Event.onGlobalSearch,e)},e.prototype.onPagination=function(e){this.page=e.page,this.limit=e.limit,this.emitEvent(n.Event.onPagination,e)},e.prototype.toggleCheckbox=function(n){this.selectedCheckboxes.has(n)?this.selectedCheckboxes.delete(n):this.selectedCheckboxes.add(n)},e.prototype.collapseRow=function(e){this.selectedDetailsTemplateRowId.has(e)?(this.selectedDetailsTemplateRowId.delete(e),this.emitEvent(n.Event.onRowCollapsedHide,e)):(this.selectedDetailsTemplateRowId.add(e),this.emitEvent(n.Event.onRowCollapsedShow,e))},e.prototype.doDecodePersistedState=function(){if(this.config.persistState){var e=localStorage.getItem(n.Event.onPagination),t=localStorage.getItem(n.Event.onOrder),o=localStorage.getItem(n.Event.onSearch);if(e&&this.onPagination(JSON.parse(e)),t){var i=JSON.parse(t),a=i.key,l=i.order;this.bindApi({type:n.API.sortBy,value:{column:a,order:l}})}o&&this.bindApi({type:n.API.setInputValue,value:JSON.parse(o)})}},e.prototype.isRowCollapsed=function(n){return!!this.config.collapseAllRows||this.selectedDetailsTemplateRowId.has(n)},Object.defineProperty(e.prototype,"loadingHeight",{get:function(){var n=document.getElementById(this.id);if(n&&n.rows&&n.rows.length>3){var e=this.config.searchEnabled?1:0,t=this.config.headerEnabled?1:0;return(n.rows.length-e-t)*(n.rows[3].offsetHeight-1)-2}return 30},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"arrowDefinition",{get:function(){return this.config.showDetailsArrow||void 0===this.config.showDetailsArrow},enumerable:!1,configurable:!0}),e.prototype.onRowContextMenu=function(e,t,o,i,a){if(this.config.showContextMenu){e.preventDefault();var l={event:e,row:t,key:o,rowId:a,colId:i};this.rowContextMenuPosition={top:e.pageY-10+"px",left:e.pageX-10+"px",value:l},this.emitEvent(n.Event.onRowContextMenu,l)}},e.prototype.doApplyData=function(n){var e=this.columns.find((function(n){return!!n.orderBy}));e?(this.sortState.set(this.sortKey,"asc"===e.orderBy?"desc":"asc"),this.orderBy(e)):this.data=c(n.currentValue)},e.prototype.onDrop=function(e){this.emitEvent(n.Event.onRowDrop,e),o.moveItemInArray(this.data,e.previousIndex,e.currentIndex)},e.prototype.apiEvent=function(n){return this.bindApi(n)},e.prototype.bindApi=function(e){var t=this;switch(e.type){case n.API.rowContextMenuClicked:this.rowContextMenuPosition={top:null,left:null,value:null};break;case n.API.toolPanelClicked:break;case n.API.toggleRowIndex:this.collapseRow(e.value);break;case n.API.toggleCheckbox:this.toggleCheckbox(e.value);break;case n.API.setInputValue:this.config.searchEnabled&&e.value.forEach((function(n){var e=document.getElementById("search_"+n.key);e?e.value=n.value:console.error("Column '"+n.key+"' not available in the DOM. Have you misspelled a name?")})),this.onSearch(e.value),this.cdr.detectChanges();break;case n.API.onGlobalSearch:this.onGlobalSearch(e.value),this.cdr.detectChanges();break;case n.API.setRowClass:if(Array.isArray(e.value)){e.value.forEach((function(n){return t.styleService.setRowClass(n)}));break}this.styleService.setRowClass(e.value),this.cdr.detectChanges();break;case n.API.setCellClass:if(Array.isArray(e.value)){e.value.forEach((function(n){return t.styleService.setCellClass(n)}));break}this.styleService.setCellClass(e.value);break;case n.API.setRowStyle:if(Array.isArray(e.value)){e.value.forEach((function(n){return t.styleService.setRowStyle(n)}));break}this.styleService.setRowStyle(e.value);break;case n.API.setCellStyle:if(Array.isArray(e.value)){e.value.forEach((function(n){return t.styleService.setCellStyle(n)}));break}this.styleService.setCellStyle(e.value);break;case n.API.setTableClass:this.tableClass=e.value,this.cdr.detectChanges();break;case n.API.getPaginationTotalItems:return this.paginationComponent.paginationDirective.getTotalItems();case n.API.getPaginationCurrentPage:return this.paginationComponent.paginationDirective.getCurrent();case n.API.getPaginationLastPage:return this.paginationComponent.paginationDirective.getLastPage();case n.API.getNumberOfRowsPerPage:return this.paginationComponent.paginationDirective.isLastPage()?this.paginationComponent.paginationDirective.getTotalItems()%this.limit:this.limit;case n.API.setPaginationCurrentPage:this.paginationComponent.paginationDirective.setCurrent(e.value);break;case n.API.setPaginationRange:this.paginationComponent.ranges=e.value;break;case n.API.setPaginationPreviousLabel:this.paginationComponent.previousLabel=e.value;break;case n.API.setPaginationNextLabel:this.paginationComponent.nextLabel=e.value;break;case n.API.setPaginationDisplayLimit:this.paginationComponent.changeLimit(e.value,!0);break;case n.API.sortBy:var o={title:"",key:e.value.column,orderBy:e.value.order};this.orderBy(o),this.cdr.detectChanges()}},e.prototype.setColumnOrder=function(n){switch(this.sortState.get(n)){case"":case void 0:this.sortState.set(n,"desc");break;case"asc":this.config.threeWaySort?this.sortState.set(n,""):this.sortState.set(n,"desc");break;case"desc":this.sortState.set(n,"asc")}if(this.sortState.size>1){var e=this.sortState.get(n);this.sortState.clear(),this.sortState.set(n,e)}},e.prototype.emitEvent=function(n,e){this.event.emit({event:n,value:e}),this.config.persistState&&localStorage.setItem(n,JSON.stringify(e)),this.config.logger&&console.log({event:n,value:e})},e}();b.decorators=[{type:t.Component,args:[{selector:"ngx-table",providers:[m,f,x],template:'<div class="ngx-container" [class.ngx-container--dark]="config.tableLayout.theme === \'dark\'">\n  <table\n    [id]="id"\n    [ngClass]="tableClass === null || tableClass === \'\' ? \'ngx-table\' : tableClass"\n    [class.ngx-table__table--tiny]="config.tableLayout.style === \'tiny\'"\n    [class.ngx-table__table--normal]="config.tableLayout.style === \'normal\'"\n    [class.ngx-table__table--big]="config.tableLayout.style === \'big\'"\n    [class.ngx-table__table--borderless]="config.tableLayout.borderless"\n    [class.ngx-table__table--dark]="config.tableLayout.theme === \'dark\'"\n    [class.ngx-table__table--hoverable]="config.tableLayout.hover"\n    [class.ngx-table__table--striped]="config.tableLayout.striped"\n    [class.ngx-table__horizontal-scroll]="config.horizontalScroll && !config.isLoading"\n  >\n    <thead\n      [class.ngx-infinite-scroll-viewport-thead]="config.infiniteScroll"\n      table-thead\n      [config]="config"\n      [sortKey]="sortKey"\n      [sortState]="sortState"\n      [selectAllTemplate]="selectAllTemplate"\n      [filtersTemplate]="filtersTemplate"\n      [additionalActionsTemplate]="additionalActionsTemplate"\n      [columns]="columns"\n      (selectAll)="onSelectAll()"\n      (filter)="onSearch($event)"\n      (order)="orderBy($event)"\n      (event)="emitEvent($event.event, $event.value)"\n    ></thead>\n    <tbody *ngIf="data && !config.isLoading && !config.rowReorder">\n      <ng-container *ngIf="rowTemplate">\n        <ul\n          class="ngx-table__table-row-context-menu"\n          [ngStyle]="{\n            position: \'absolute\',\n            top: rowContextMenuPosition.top,\n            left: rowContextMenuPosition.left\n          }"\n          *ngIf="rowContextMenuPosition.top"\n        >\n          <ng-container\n            [ngTemplateOutlet]="rowContextMenu"\n            [ngTemplateOutletContext]="{ $implicit: rowContextMenuPosition.value }"\n          >\n          </ng-container>\n        </ul>\n        <ng-container *ngIf="!config.infiniteScroll">\n          <ng-container\n            *ngFor="\n              let row of data\n                | sort: sortBy\n                | search: term:filteredCountSubject\n                | global: globalSearchTerm:filteredCountSubject\n                | paginate: { itemsPerPage: limit, currentPage: page, totalItems: count, id: id };\n              let rowIndex = index\n            "\n          >\n            <tr\n              (click)="onClick($event, row, \'\', null, rowIndex)"\n              #contextMenu\n              (contextmenu)="onRowContextMenu($event, row, \'\', null, rowIndex)"\n              (dblclick)="onDoubleClick($event, row, \'\', null, rowIndex)"\n              [class.ngx-table__table-row--selected]="\n                rowIndex === selectedRow && !config.selectCell\n              "\n            >\n              <ng-container\n                [ngTemplateOutlet]="rowTemplate"\n                [ngTemplateOutletContext]="{ $implicit: row, index: rowIndex }"\n              >\n              </ng-container>\n              <td *ngIf="config.detailsTemplate">\n                <span\n                  class="ngx-icon"\n                  *ngIf="arrowDefinition"\n                  [ngClass]="\n                    isRowCollapsed(rowIndex) ? \'ngx-icon-arrow-down\' : \'ngx-icon-arrow-right\'\n                  "\n                  (click)="collapseRow(rowIndex)"\n                >\n                </span>\n              </td>\n            </tr>\n            <tr\n              *ngIf="\n                (config.detailsTemplate && selectedDetailsTemplateRowId.has(rowIndex)) ||\n                config.collapseAllRows\n              "\n            >\n              <td [attr.colspan]="columns.length + 1">\n                <ng-container\n                  [ngTemplateOutlet]="detailsTemplate"\n                  [ngTemplateOutletContext]="{ $implicit: row, index: rowIndex }"\n                >\n                </ng-container>\n              </td>\n            </tr>\n          </ng-container>\n        </ng-container>\n        <cdk-virtual-scroll-viewport\n          itemSize="50"\n          *ngIf="config.infiniteScroll"\n          class="ngx-infinite-scroll-viewport"\n        >\n          <ng-container\n            *cdkVirtualFor="\n              let row of data\n                | sort: sortBy\n                | search: term:filteredCountSubject\n                | global: globalSearchTerm:filteredCountSubject;\n              let rowIndex = index\n            "\n          >\n            <tr\n              (click)="onClick($event, row, \'\', null, rowIndex)"\n              #contextMenu\n              (contextmenu)="onRowContextMenu($event, row, \'\', null, rowIndex)"\n              (dblclick)="onDoubleClick($event, row, \'\', null, rowIndex)"\n              [class.ngx-table__table-row--selected]="\n                rowIndex === selectedRow && !config.selectCell\n              "\n            >\n              <ng-container\n                [ngTemplateOutlet]="rowTemplate"\n                [ngTemplateOutletContext]="{ $implicit: row, index: rowIndex }"\n              >\n              </ng-container>\n              <td *ngIf="config.detailsTemplate">\n                <span\n                  class="ngx-icon"\n                  *ngIf="arrowDefinition"\n                  [ngClass]="\n                    isRowCollapsed(rowIndex) ? \'ngx-icon-arrow-down\' : \'ngx-icon-arrow-right\'\n                  "\n                  (click)="collapseRow(rowIndex)"\n                >\n                </span>\n              </td>\n            </tr>\n            <tr\n              *ngIf="\n                (config.detailsTemplate && selectedDetailsTemplateRowId.has(rowIndex)) ||\n                config.collapseAllRows\n              "\n            >\n              <td [attr.colspan]="columns.length + 1">\n                <ng-container\n                  [ngTemplateOutlet]="detailsTemplate"\n                  [ngTemplateOutletContext]="{ $implicit: row, index: rowIndex }"\n                >\n                </ng-container>\n              </td>\n            </tr>\n          </ng-container>\n        </cdk-virtual-scroll-viewport>\n      </ng-container>\n      <ng-container *ngIf="!rowTemplate && !config.groupRows">\n        <ul\n          class="ngx-table__table-row-context-menu"\n          [ngStyle]="{\n            position: \'absolute\',\n            top: rowContextMenuPosition.top,\n            left: rowContextMenuPosition.left\n          }"\n          *ngIf="rowContextMenuPosition.top"\n        >\n          <ng-container\n            [ngTemplateOutlet]="rowContextMenu"\n            [ngTemplateOutletContext]="{ $implicit: rowContextMenuPosition.value }"\n          >\n          </ng-container>\n        </ul>\n        <ng-container *ngIf="!config.infiniteScroll">\n          <ng-container\n            *ngFor="\n              let row of data\n                | sort: sortBy\n                | search: term:filteredCountSubject\n                | global: globalSearchTerm:filteredCountSubject\n                | paginate: { itemsPerPage: limit, currentPage: page, totalItems: count, id: id };\n              let rowIndex = index\n            "\n          >\n            <tr\n              [class.ngx-table__table-row--selected]="\n                rowIndex === selectedRow && !config.selectCell\n              "\n            >\n              <td *ngIf="config.checkboxes">\n                <label class="ngx-form-checkbox">\n                  <input\n                    type="checkbox"\n                    id="checkbox-{{ rowIndex }}"\n                    [checked]="isSelected || selectedCheckboxes.has(rowIndex)"\n                    (change)="onCheckboxSelect($event, row, rowIndex)"\n                  />\n                  <em class="ngx-form-icon"></em>\n                </label>\n              </td>\n              <td *ngIf="config.radio">\n                <label>\n                  <input\n                    type="radio"\n                    id="radio-{{ rowIndex }}"\n                    name="radio"\n                    (change)="onRadioSelect($event, row, rowIndex)"\n                  />\n                </label>\n              </td>\n              <ng-container *ngFor="let column of columns; let colIndex = index">\n                <td\n                  (click)="onClick($event, row, column.key, colIndex, rowIndex)"\n                  #contextMenu\n                  (contextmenu)="onRowContextMenu($event, row, column.key, colIndex, rowIndex)"\n                  (dblclick)="onDoubleClick($event, row, column.key, colIndex, rowIndex)"\n                  [class.pinned-left]="column.pinned"\n                  [ngClass]="column.cssClass ? column.cssClass.name : \'\'"\n                  [style.left]="styleService.pinnedWidth(column.pinned, colIndex)"\n                  [class.ngx-table__table-col--selected]="\n                    colIndex === selectedCol && !config.selectCell\n                  "\n                  [class.ngx-table__table-cell--selected]="\n                    colIndex === selectedCol &&\n                    rowIndex === selectedRow &&\n                    !config.selectCol &&\n                    !config.selectRow\n                  "\n                >\n                  <div *ngIf="!column.cellTemplate">{{ row | render: column.key }}</div>\n                  <ng-container\n                    *ngIf="column.cellTemplate"\n                    [ngTemplateOutlet]="column.cellTemplate"\n                    [ngTemplateOutletContext]="{\n                      $implicit: row,\n                      rowIndex: rowIndex,\n                      column: column\n                    }"\n                  >\n                  </ng-container>\n                </td>\n              </ng-container>\n              <td *ngIf="config.additionalActions || config.detailsTemplate">\n                <span\n                  class="ngx-icon"\n                  *ngIf="arrowDefinition"\n                  [ngClass]="\n                    isRowCollapsed(rowIndex) ? \'ngx-icon-arrow-down\' : \'ngx-icon-arrow-right\'\n                  "\n                  (click)="collapseRow(rowIndex)"\n                >\n                </span>\n              </td>\n            </tr>\n            <tr\n              *ngIf="\n                (config.detailsTemplate && selectedDetailsTemplateRowId.has(rowIndex)) ||\n                config.collapseAllRows\n              "\n            >\n              <td *ngIf="config.checkboxes || config.radio"></td>\n              <td [attr.colspan]="columns.length + 1">\n                <ng-container\n                  [ngTemplateOutlet]="detailsTemplate"\n                  [ngTemplateOutletContext]="{ $implicit: row, index: rowIndex }"\n                >\n                </ng-container>\n              </td>\n            </tr>\n          </ng-container>\n        </ng-container>\n        \x3c!-- infinite scroll --\x3e\n        <cdk-virtual-scroll-viewport\n          itemSize="50"\n          *ngIf="config.infiniteScroll"\n          class="ngx-infinite-scroll-viewport"\n        >\n          <ng-container\n            *cdkVirtualFor="\n              let row of data\n                | sort: sortBy\n                | search: term:filteredCountSubject\n                | global: globalSearchTerm:filteredCountSubject;\n              let rowIndex = index\n            "\n          >\n            <tr\n              [class.ngx-table__table-row--selected]="\n                rowIndex === selectedRow && !config.selectCell\n              "\n            >\n              <td *ngIf="config.checkboxes">\n                <label class="ngx-form-checkbox">\n                  <input\n                    type="checkbox"\n                    id="checkbox-infinite-scroll-{{ rowIndex }}"\n                    [checked]="isSelected || selectedCheckboxes.has(rowIndex)"\n                    (change)="onCheckboxSelect($event, row, rowIndex)"\n                  />\n                  <em class="ngx-form-icon"></em>\n                </label>\n              </td>\n              <td *ngIf="config.radio">\n                <label>\n                  <input\n                    type="radio"\n                    id="radio-infinite-scroll-{{ rowIndex }}"\n                    name="radio"\n                    (change)="onRadioSelect($event, row, rowIndex)"\n                  />\n                </label>\n              </td>\n              <ng-container *ngFor="let column of columns; let colIndex = index">\n                <td\n                  (click)="onClick($event, row, column.key, colIndex, rowIndex)"\n                  #contextMenu\n                  (contextmenu)="onRowContextMenu($event, row, column.key, colIndex, rowIndex)"\n                  (dblclick)="onDoubleClick($event, row, column.key, colIndex, rowIndex)"\n                  [class.pinned-left]="column.pinned"\n                  [ngClass]="column.cssClass ? column.cssClass.name : \'\'"\n                  [style.left]="styleService.pinnedWidth(column.pinned, colIndex)"\n                  [class.ngx-table__table-col--selected]="\n                    colIndex === selectedCol && !config.selectCell\n                  "\n                  [class.ngx-table__table-cell--selected]="\n                    colIndex === selectedCol &&\n                    rowIndex === selectedRow &&\n                    !config.selectCol &&\n                    !config.selectRow\n                  "\n                >\n                  <div *ngIf="!column.cellTemplate">{{ row | render: column.key }}</div>\n                  <ng-container\n                    *ngIf="column.cellTemplate"\n                    [ngTemplateOutlet]="column.cellTemplate"\n                    [ngTemplateOutletContext]="{\n                      $implicit: row,\n                      rowIndex: rowIndex,\n                      column: column\n                    }"\n                  >\n                  </ng-container>\n                </td>\n              </ng-container>\n              <td *ngIf="config.additionalActions || config.detailsTemplate">\n                <span\n                  class="ngx-icon"\n                  *ngIf="arrowDefinition"\n                  [ngClass]="\n                    isRowCollapsed(rowIndex) ? \'ngx-icon-arrow-down\' : \'ngx-icon-arrow-right\'\n                  "\n                  (click)="collapseRow(rowIndex)"\n                >\n                </span>\n              </td>\n            </tr>\n            <tr\n              *ngIf="\n                (config.detailsTemplate && selectedDetailsTemplateRowId.has(rowIndex)) ||\n                config.collapseAllRows\n              "\n            >\n              <td *ngIf="config.checkboxes || config.radio"></td>\n              <td [attr.colspan]="columns.length + 1">\n                <ng-container\n                  [ngTemplateOutlet]="detailsTemplate"\n                  [ngTemplateOutletContext]="{ $implicit: row, index: rowIndex }"\n                >\n                </ng-container>\n              </td>\n            </tr>\n          </ng-container>\n        </cdk-virtual-scroll-viewport>\n      </ng-container>\n      <ng-container *ngIf="!rowTemplate && config.groupRows">\n        <ng-container\n          *ngFor="\n            let group of grouped\n              | sort: sortBy:config\n              | search: term:filteredCountSubject:config\n              | global: globalSearchTerm:filteredCountSubject\n              | paginate: { itemsPerPage: limit, currentPage: page, totalItems: count, id: id };\n            let rowIndex = index\n          "\n        >\n          <tr>\n            <ng-container *ngIf="!groupRowsHeaderTemplate">\n              <td [attr.colspan]="columns.length">\n                <div>{{ group[0][groupRowsBy] }} ({{ group.length }})</div>\n              </td>\n            </ng-container>\n            <ng-container\n              *ngIf="groupRowsHeaderTemplate"\n              [ngTemplateOutlet]="groupRowsHeaderTemplate"\n              [ngTemplateOutletContext]="{\n                total: group.length,\n                key: groupRowsBy,\n                value: group[0] ? group[0][groupRowsBy] : \'\',\n                group: group,\n                index: rowIndex\n              }"\n            >\n            </ng-container>\n            <td>\n              <span\n                class="ngx-icon"\n                *ngIf="arrowDefinition"\n                [ngClass]="\n                  isRowCollapsed(rowIndex) ? \'ngx-icon-arrow-down\' : \'ngx-icon-arrow-right\'\n                "\n                (click)="collapseRow(rowIndex)"\n              >\n              </span>\n            </td>\n          </tr>\n          <ng-container *ngIf="selectedDetailsTemplateRowId.has(rowIndex)">\n            <tr *ngFor="let row of group">\n              <td *ngFor="let column of columns">\n                {{ row | render: column.key }}\n                \x3c!-- TODO allow users to add groupRowsTemplateRef --\x3e\n              </td>\n              <td></td>\n            </tr>\n          </ng-container>\n        </ng-container>\n      </ng-container>\n    </tbody>\n    <tbody\n      *ngIf="data && !config.isLoading && config.rowReorder"\n      class="ngx-draggable-row-area"\n      cdkDropList\n      (cdkDropListDropped)="onDrop($event)"\n    >\n      <ng-container *ngIf="!rowTemplate && !config.groupRows">\n        <ng-container\n          *ngFor="\n            let row of data\n              | sort: sortBy\n              | search: term:filteredCountSubject\n              | global: globalSearchTerm:filteredCountSubject\n              | paginate: { itemsPerPage: limit, currentPage: page, totalItems: count, id: id };\n            let rowIndex = index\n          "\n        >\n          <tr class="ngx-draggable-row" cdkDrag cdkDragLockAxis="y">\n            <td *ngIf="config.checkboxes">\n              <label class="ngx-form-checkbox">\n                <input\n                  type="checkbox"\n                  id="checkbox-draggable-{{ rowIndex }}"\n                  [checked]="isSelected || selectedCheckboxes.has(rowIndex)"\n                  (change)="onCheckboxSelect($event, row, rowIndex)"\n                />\n                <em class="ngx-form-icon"></em>\n              </label>\n            </td>\n            <td *ngIf="config.radio">\n              <label>\n                <input\n                  type="radio"\n                  id="radio-draggable-{{ rowIndex }}"\n                  name="radio"\n                  (change)="onRadioSelect($event, row, rowIndex)"\n                />\n              </label>\n            </td>\n            <ng-container *ngFor="let column of columns; let colIndex = index">\n              <td\n                (click)="onClick($event, row, column.key, colIndex, rowIndex)"\n                (dblclick)="onDoubleClick($event, row, column.key, colIndex, rowIndex)"\n                [class.ngx-table__table-col--selected]="\n                  colIndex === selectedCol && !config.selectCell\n                "\n                [class.ngx-table__table-cell--selected]="\n                  colIndex === selectedCol &&\n                  rowIndex === selectedRow &&\n                  !config.selectCol &&\n                  !config.selectRow\n                "\n              >\n                <div *ngIf="!column.cellTemplate">{{ row | render: column.key }}</div>\n                <ng-container\n                  *ngIf="column.cellTemplate"\n                  [ngTemplateOutlet]="column.cellTemplate"\n                  [ngTemplateOutletContext]="{\n                    $implicit: row,\n                    rowIndex: rowIndex,\n                    column: column\n                  }"\n                >\n                </ng-container>\n              </td>\n            </ng-container>\n          </tr>\n        </ng-container>\n      </ng-container>\n    </tbody>\n    <tbody *ngIf="filterCount === 0">\n      <tr class="ngx-table__body-empty">\n        <ng-container *ngIf="noResultsTemplate" [ngTemplateOutlet]="noResultsTemplate">\n        </ng-container>\n        <td [attr.colspan]="columns && columns.length + 1" *ngIf="!noResultsTemplate">\n          <div class="ngx-table__table-no-results">No results</div>\n        </td>\n      </tr>\n    </tbody>\n    <tbody *ngIf="config.isLoading">\n      <tr class="ngx-table__body-loading">\n        <ng-container *ngIf="loadingTemplate" [ngTemplateOutlet]="loadingTemplate"> </ng-container>\n        <td [attr.colspan]="columns && columns.length + 1" *ngIf="!loadingTemplate">\n          <div [style.height.px]="loadingHeight" class="ngx-table__table-loader-wrapper">\n            <div class="ngx-table__table-loader"></div>\n          </div>\n        </td>\n      </tr>\n    </tbody>\n    <tfoot *ngIf="summaryTemplate">\n      <tr>\n        <ng-container\n          [ngTemplateOutlet]="summaryTemplate"\n          [ngTemplateOutletContext]="{ total: data.length, limit: limit, page: page }"\n        >\n        </ng-container>\n      </tr>\n    </tfoot>\n  </table>\n  <pagination\n    [attr.id]="\'pagination\' + id"\n    [id]="id"\n    #paginationComponent\n    [config]="config"\n    [pagination]="pagination"\n    (updateRange)="onPagination($event)"\n  >\n  </pagination>\n</div>\n',changeDetection:t.ChangeDetectionStrategy.OnPush}]}],b.ctorParameters=function(){return[{type:t.ChangeDetectorRef},{type:l.ScrollDispatcher},{type:x}]},b.propDecorators={configuration:[{type:t.Input}],data:[{type:t.Input}],pagination:[{type:t.Input}],groupRowsBy:[{type:t.Input}],id:[{type:t.Input}],toggleRowIndex:[{type:t.Input}],detailsTemplate:[{type:t.Input}],summaryTemplate:[{type:t.Input}],groupRowsHeaderTemplate:[{type:t.Input}],filtersTemplate:[{type:t.Input}],selectAllTemplate:[{type:t.Input}],noResultsTemplate:[{type:t.Input}],loadingTemplate:[{type:t.Input}],additionalActionsTemplate:[{type:t.Input}],rowContextMenu:[{type:t.Input}],columns:[{type:t.Input}],event:[{type:t.Output}],rowTemplate:[{type:t.ContentChild,args:[t.TemplateRef,{static:!0}]}],paginationComponent:[{type:t.ViewChild,args:["paginationComponent"]}],contextMenu:[{type:t.ViewChild,args:["contextMenu"]}],viewPort:[{type:t.ViewChild,args:[l.CdkVirtualScrollViewport]}],onContextMenuClick:[{type:t.HostListener,args:["document:click",["$event.target"]]}]};var w=function(){function n(){this.update=new t.EventEmitter}return n.prototype.unifyKey=function(n){return n.replace(".","_")},n.prototype.onSearch=function(n){this.update.emit([{value:n.value,key:this.column.key}])},n}();w.decorators=[{type:t.Component,args:[{selector:"table-header",template:'<label for="search_{{ unifyKey(column.key) }}">\n  <input\n    type="text"\n    id="search_{{ unifyKey(column.key) }}"\n    aria-label="Search"\n    placeholder="{{ column.placeholder ? column.placeholder : column.title }}"\n    class="ngx-table__header-search"\n    #input\n    (input)="onSearch(input)"\n  />\n</label>\n',changeDetection:t.ChangeDetectionStrategy.OnPush}]}],w.propDecorators={column:[{type:t.Input}],update:[{type:t.Output}]};var y=function(){function n(){this.updateRange=new t.EventEmitter,this.ranges=[5,10,25,50,100],this.showRange=!1,this.screenReaderPaginationLabel="Pagination",this.screenReaderPageLabel="page",this.screenReaderCurrentLabel="You are on page",this.previousLabel="",this.nextLabel="",this.directionLinks=!0}return n.prototype.onClick=function(n){this.paginationRange&&!this.paginationRange.nativeElement.contains(n)&&(this.showRange=!1)},n.prototype.ngOnChanges=function(n){var e=n.config;e&&e.currentValue&&(this.selectedLimit=this.config.rows)},n.prototype.onPageChange=function(n){this.updateRange.emit({page:n,limit:this.selectedLimit})},n.prototype.changeLimit=function(n,e){e||(this.showRange=!this.showRange),this.selectedLimit=n,this.updateRange.emit({page:1,limit:n})},n}();y.decorators=[{type:t.Component,args:[{selector:"pagination",template:'<div\n  class="ngx-pagination-wrapper"\n  [style.display]="config.paginationEnabled ? \'\' : \'none\'"\n  [class.ngx-table__table--dark-pagination-wrapper]="config.tableLayout.theme === \'dark\'"\n>\n  <div class="ngx-pagination-steps">\n    <pagination-template\n      #paginationDirective="paginationApi"\n      id="pagination-controls"\n      [id]="id"\n      [class.ngx-table__table--dark-pagination]="config.tableLayout.theme === \'dark\'"\n      [maxSize]="config.paginationMaxSize || 5"\n      (pageChange)="onPageChange($event)"\n    >\n      <ul\n        class="ngx-pagination"\n        role="navigation"\n        [attr.aria-label]="screenReaderPaginationLabel"\n        [class.responsive]="true"\n      >\n        <li\n          class="pagination-previous"\n          [class.disabled]="paginationDirective.isFirstPage()"\n          *ngIf="directionLinks"\n        >\n          <a\n            tabindex="0"\n            *ngIf="1 < paginationDirective.getCurrent()"\n            (keyup.enter)="paginationDirective.previous()"\n            (click)="paginationDirective.previous()"\n            [attr.aria-label]="previousLabel + \' \' + screenReaderPageLabel"\n          >\n            {{ previousLabel }} <span class="show-for-sr">{{ screenReaderPageLabel }}</span>\n          </a>\n          <span *ngIf="paginationDirective.isFirstPage()">\n            {{ previousLabel }} <span class="show-for-sr">{{ screenReaderPageLabel }}</span>\n          </span>\n        </li>\n        <li class="small-screen">\n          {{ paginationDirective.getCurrent() }} / {{ paginationDirective.getLastPage() }}\n        </li>\n        <li\n          [class.current]="paginationDirective.getCurrent() === page.value"\n          [class.ellipsis]="page.label === \'...\'"\n          *ngFor="let page of paginationDirective.pages"\n        >\n          <a\n            tabindex="0"\n            (keyup.enter)="paginationDirective.setCurrent(page.value)"\n            (click)="paginationDirective.setCurrent(page.value)"\n            *ngIf="paginationDirective.getCurrent() !== page.value"\n          >\n            <span class="show-for-sr">{{ screenReaderPageLabel }} </span>\n            <span>{{ page.label }}</span>\n          </a>\n          <ng-container *ngIf="paginationDirective.getCurrent() === page.value">\n            <span class="show-for-sr">{{ screenReaderCurrentLabel }} </span>\n            <span>{{ page.label }}</span>\n          </ng-container>\n        </li>\n        <li\n          class="pagination-next"\n          [class.disabled]="paginationDirective.isLastPage()"\n          *ngIf="directionLinks"\n        >\n          <a\n            tabindex="0"\n            *ngIf="!paginationDirective.isLastPage()"\n            (keyup.enter)="paginationDirective.next()"\n            (click)="paginationDirective.next()"\n            [attr.aria-label]="nextLabel + \' \' + screenReaderPageLabel"\n          >\n            {{ nextLabel }} <span class="show-for-sr">{{ screenReaderPageLabel }}</span>\n          </a>\n          <span *ngIf="paginationDirective.isLastPage()">\n            {{ nextLabel }} <span class="show-for-sr">{{ screenReaderPageLabel }}</span>\n          </span>\n        </li>\n      </ul>\n    </pagination-template>\n  </div>\n  <div\n    class="ngx-pagination-range"\n    #paginationRange\n    [class.ngx-table__table--dark-pagination-range]="config.tableLayout.theme === \'dark\'"\n    *ngIf="config.paginationRangeEnabled"\n  >\n    <div class="ngx-dropdown ngx-pagination-range-dropdown" id="rowAmount">\n      <div class="ngx-btn-group">\n        <div class="ngx-pagination-range-dropdown-button" (click)="showRange = !showRange">\n          {{selectedLimit}} <i class="ngx-icon ngx-icon-arrow-down"></i>\n        </div>\n        <ul class="ngx-menu" *ngIf="showRange">\n          <li\n            class="ngx-pagination-range-dropdown-button-item"\n            [class.ngx-pagination-range--selected]="limit === selectedLimit"\n            (click)="changeLimit(limit, false)"\n            *ngFor="let limit of ranges"\n          >\n            <span>{{limit}}</span>\n          </li>\n        </ul>\n      </div>\n    </div>\n  </div>\n</div>\n',changeDetection:t.ChangeDetectionStrategy.OnPush}]}],y.propDecorators={paginationDirective:[{type:t.ViewChild,args:["paginationDirective",{static:!0}]}],paginationRange:[{type:t.ViewChild,args:["paginationRange"]}],pagination:[{type:t.Input}],config:[{type:t.Input}],id:[{type:t.Input}],updateRange:[{type:t.Output}],onClick:[{type:t.HostListener,args:["document:click",["$event.target"]]}]};var v=function(){function n(){}return n.prototype.transform=function(n,e,t){if(t.next(0),void 0!==n){if(void 0===e||0===Object.keys(e).length||""===e)return t.next(n.length),n;var o=n.filter((function(n){var t=JSON.stringify(Object.values(n));return e.split(",").some((function(n){return t.toLocaleLowerCase().indexOf(n.trim().toLocaleLowerCase())>-1}))}));return t.next(o.length),o}},n}();v.decorators=[{type:t.Pipe,args:[{name:"global"}]}];var I=function(){function n(){}return n.getPath=function(n,e){return n.reduce((function(n,e){return n&&void 0!==n[e]?n[e]:null}),e)},n}();I.decorators=[{type:t.Injectable}];var C=function(){function n(){}return n.prototype.transform=function(n,e){var t=e.split(".");return I.getPath(t,n)},n}();C.decorators=[{type:t.Pipe,args:[{name:"render"}]}];var k=function(){function n(){this.filters={}}return n.prototype.transform=function(n,e,t,o){var i=this;if(t.next(0),void 0!==n)return void 0===e?(t.next(n.length),n):(e.forEach((function(n){i.filters[n.key]=n.value.toString().toLocaleLowerCase(),0!==Object.keys(n).length&&""!==n.value||delete i.filters[n.key]})),o&&o.groupRows?n.map((function(n){return i.filterGroup(n,t)})):this.filterGroup(n,t))},n.prototype.filterGroup=function(n,e){var t=this,o=n.filter((function(n){return Object.keys(t.filters).every((function(e){var o=e.split("."),i=I.getPath(o,n),a="object"==typeof i?JSON.stringify(i):i.toString().toLocaleLowerCase();return t.filters[e].split(",").some((function(n){return a.indexOf(n.trim())>-1}))}))}));return e.next(o.length),o},n}();k.decorators=[{type:t.Pipe,args:[{name:"search"}]}];var S=function(){function n(){this.defaultArray=[]}return n.isNaN=function(n,e){return isNaN(parseFloat(n))||!isFinite(n)||isNaN(parseFloat(e))||!isFinite(e)},n.compare=function(e,t,o){var i=o.split("."),a=I.getPath(i,e),l=I.getPath(i,t),r=(a+"").toLowerCase(),s=(l+"").toLowerCase();return n.isNaN(a,l)?r.localeCompare(s):parseFloat(a)<parseFloat(l)?-1:parseFloat(a)>parseFloat(l)?1:0},n.prototype.transform=function(n,e,t){return 0===this.defaultArray.length&&(this.defaultArray=n),e.key&&""!==e.key?""===e.order?this.defaultArray:"asc"===e.order?this.sortAsc(n,e,t):this.sortDesc(n,e,t):n},n.prototype.sortAsc=function(e,t,o){return o&&o.groupRows?e.map((function(e){return e.sort((function(e,o){return n.compare(e,o,t.key)}))})):e.sort((function(e,o){return n.compare(e,o,t.key)}))},n.prototype.sortDesc=function(e,t,o){return o&&o.groupRows?e.map((function(e){return e.sort((function(e,o){return n.compare(o,e,t.key)}))})):e.sort((function(e,o){return n.compare(o,e,t.key)}))},n}();S.decorators=[{type:t.Pipe,args:[{name:"sort"}]}];var R=function(){function e(n){this.styleService=n,this.menuActive=!1,this.openedHeaderActionTemplate=null,this.onSelectAllBinded=this.onSelectAll.bind(this),this.filter=new t.EventEmitter,this.order=new t.EventEmitter,this.selectAll=new t.EventEmitter,this.event=new t.EventEmitter}return e.prototype.onClick=function(n){this.additionalActionMenu&&!this.additionalActionMenu.nativeElement.contains(n)&&(this.menuActive=!1)},e.prototype.getColumnDefinition=function(n){return n.searchEnabled||void 0===n.searchEnabled},e.prototype.orderBy=function(n){this.order.emit(n)},e.prototype.isOrderEnabled=function(n){var e=void 0===n.orderEnabled||!!n.orderEnabled;return this.config.orderEnabled&&e},e.prototype.columnDrop=function(n){o.moveItemInArray(this.columns,n.previousIndex,n.currentIndex)},e.prototype.onSearch=function(n){this.filter.emit(n)},e.prototype.getColumnWidth=function(n){return n.width?n.width:this.config.fixedColumnWidth?100/this.columns.length+"%":null},e.prototype.onSelectAll=function(){this.selectAll.emit()},e.prototype.onMouseDown=function(e,t){this.config.resizeColumn&&(this.th=t,this.startOffset=t.offsetWidth-e.pageX,this.event.emit({event:n.Event.onColumnResizeMouseDown,value:e}))},e.prototype.onMouseMove=function(n){this.config.resizeColumn&&this.th&&this.th.style&&(this.th.style.width=this.startOffset+n.pageX+"px",this.th.style.cursor="col-resize",this.th.style["user-select"]="none")},e.prototype.onMouseUp=function(e){this.config.resizeColumn&&(this.event.emit({event:n.Event.onColumnResizeMouseUp,value:e}),this.th.style.cursor="default",this.th=void 0)},e.prototype.showHeaderActionTemplateMenu=function(n){n.headerActionTemplate||console.error("Column [headerActionTemplate] property not defined"),this.openedHeaderActionTemplate!==n.key?this.openedHeaderActionTemplate=n.key:this.openedHeaderActionTemplate=null},e.prototype.showMenu=function(){this.additionalActionsTemplate||console.error("[additionalActionsTemplate] property not defined"),this.menuActive=!this.menuActive},e}();R.decorators=[{type:t.Component,args:[{selector:"[table-thead]",template:'<tr class="ngx-table__header" *ngIf="config.headerEnabled && !config.columnReorder">\n  <th *ngIf="config.checkboxes || config.radio" [style.width]="\'3%\'">\n    <ng-container\n      *ngIf="selectAllTemplate && config.checkboxes"\n      [ngTemplateOutlet]="selectAllTemplate"\n      [ngTemplateOutletContext]="{ $implicit: onSelectAllBinded }"\n    >\n    </ng-container>\n    <label\n      class="ngx-form-checkbox"\n      for="selectAllCheckboxes"\n      *ngIf="!selectAllTemplate && config.checkboxes"\n    >\n      <input type="checkbox" id="selectAllCheckboxes" (change)="onSelectAll()" />\n      <em class="ngx-form-icon" id="selectAllCheckbox"></em>\n    </label>\n  </th>\n  <ng-container *ngFor="let column of columns; let colIndex = index; let last = last">\n    <th\n      class="ngx-table__header-cell"\n      [class.pinned-left]="column.pinned"\n      [ngClass]="column.cssClass && column.cssClass.includeHeader ? column.cssClass.name : \'\'"\n      [style.left]="styleService.pinnedWidth(column.pinned, colIndex)"\n      #th\n      [style.width]="getColumnWidth(column)"\n      (mousedown)="onMouseDown($event, th)"\n      (mouseup)="onMouseUp($event)"\n      (mousemove)="onMouseMove($event)"\n    >\n      <div\n        (click)="orderBy(column)"\n        style="display: inline"\n        [class.pointer]="isOrderEnabled(column)"\n      >\n        <div class="ngx-table__header-title">\n          {{ column.title }}<span>&nbsp;</span>\n          <em class="ngx-icon ngx-icon-pin" *ngIf="column.pinned"></em>\n          <div [style.display]="config.orderEnabled ? \'inline\' : \'none\'">\n            <em\n              *ngIf="sortKey === column.key && this.sortState.get(sortKey) === \'asc\'"\n              class="ngx-icon ngx-icon-arrow-up"\n            >\n            </em>\n            <em\n              *ngIf="sortKey === column.key && this.sortState.get(sortKey) === \'desc\'"\n              class="ngx-icon ngx-icon-arrow-down"\n            >\n            </em>\n          </div>\n        </div>\n      </div>\n      <div class="ngx-dropdown" *ngIf="!!column.headerActionTemplate">\n        <a class="ngx-btn ngx-btn-link" (click)="showHeaderActionTemplateMenu(column)">\n          <span class="ngx-icon ngx-icon-more"></span>\n        </a>\n        <div\n          class="ngx-menu ngx-table__table-menu"\n          *ngIf="column.key === openedHeaderActionTemplate"\n        >\n          <ng-container [ngTemplateOutlet]="column.headerActionTemplate"> </ng-container>\n        </div>\n      </div>\n      <div class="ngx-table__column-resizer" *ngIf="config.resizeColumn && !last"></div>\n    </th>\n  </ng-container>\n  <th\n    *ngIf="\n      config.additionalActions ||\n      config.detailsTemplate ||\n      config.collapseAllRows ||\n      config.groupRows\n    "\n    class="ngx-table__header-cell-additional-actions"\n  >\n    <div class="ngx-dropdown" #additionalActionMenu *ngIf="config.additionalActions">\n      <a class="ngx-btn ngx-btn-link" (click)="showMenu()">\n        <span class="ngx-icon ngx-icon-menu"></span>\n      </a>\n      <ul class="ngx-menu ngx-table__table-menu" *ngIf="menuActive">\n        <ng-container\n          *ngIf="additionalActionsTemplate"\n          [ngTemplateOutlet]="additionalActionsTemplate"\n        >\n        </ng-container>\n      </ul>\n    </div>\n  </th>\n</tr>\n<tr\n  class="ngx-table__header ngx-table__header--draggable"\n  *ngIf="config.headerEnabled && config.columnReorder"\n  cdkDropList\n  cdkDropListOrientation="horizontal"\n  (cdkDropListDropped)="columnDrop($event)"\n>\n  <th *ngIf="config.checkboxes || config.radio" [style.width]="\'3%\'">\n    <ng-container\n      *ngIf="selectAllTemplate && config.checkboxes"\n      [ngTemplateOutlet]="selectAllTemplate"\n      [ngTemplateOutletContext]="{ $implicit: onSelectAllBinded }"\n    >\n    </ng-container>\n    <label\n      class="ngx-form-checkbox"\n      for="selectAllCheckboxes"\n      *ngIf="!selectAllTemplate && config.checkboxes"\n    >\n      <input type="checkbox" id="selectAllCheckboxesDrag" (change)="onSelectAll()" />\n      <em class="ngx-form-icon" id="selectAllCheckboxDrag"></em>\n    </label>\n  </th>\n  <ng-container *ngFor="let column of columns; let colIndex = index; let last = last">\n    <th\n      class="ngx-table__header-cell ngx-table__header-cell--draggable"\n      cdkDragLockAxis="x"\n      cdkDrag\n      [class.pinned-left]="column.pinned"\n      [ngClass]="column.cssClass && column.cssClass.includeHeader ? column.cssClass.name : \'\'"\n      [style.left]="styleService.pinnedWidth(column.pinned, colIndex)"\n      #th\n      [style.width]="getColumnWidth(column)"\n      (mousedown)="onMouseDown($event, th)"\n      (mouseup)="onMouseUp($event)"\n      (mousemove)="onMouseMove($event)"\n    >\n      <div\n        (click)="orderBy(column)"\n        style="display: inline"\n        cdkDragHandle\n        [class.pointer]="isOrderEnabled(column)"\n      >\n        <div class="ngx-table__header-title">\n          {{ column.title }}<span>&nbsp;</span>\n          <em class="ngx-icon ngx-icon-pin" *ngIf="column.pinned"></em>\n          <div [style.display]="config.orderEnabled ? \'inline\' : \'none\'">\n            <em\n              *ngIf="sortKey === column.key && this.sortState.get(sortKey) === \'asc\'"\n              class="ngx-icon ngx-icon-arrow-up"\n            >\n            </em>\n            <em\n              *ngIf="sortKey === column.key && this.sortState.get(sortKey) === \'desc\'"\n              class="ngx-icon ngx-icon-arrow-down"\n            >\n            </em>\n          </div>\n        </div>\n      </div>\n      <div class="ngx-dropdown" *ngIf="!!column.headerActionTemplate">\n        <a class="ngx-btn ngx-btn-link" (click)="showHeaderActionTemplateMenu(column)">\n          <span class="ngx-icon ngx-icon-more"></span>\n        </a>\n        <div\n          class="ngx-menu ngx-table__table-menu"\n          *ngIf="column.key === openedHeaderActionTemplate"\n        >\n          <ng-container [ngTemplateOutlet]="column.headerActionTemplate"> </ng-container>\n        </div>\n      </div>\n      <div class="ngx-table__column-resizer" *ngIf="config.resizeColumn && !last"></div>\n    </th>\n  </ng-container>\n  <th\n    *ngIf="\n      config.additionalActions ||\n      config.detailsTemplate ||\n      config.collapseAllRows ||\n      config.groupRows\n    "\n    class="ngx-table__header-cell-additional-actions"\n  >\n    <div class="ngx-dropdown" #additionalActionMenu *ngIf="config.additionalActions">\n      <a class="ngx-btn ngx-btn-link" (click)="showMenu()">\n        <span class="ngx-icon ngx-icon-menu"></span>\n      </a>\n      <ul class="ngx-menu ngx-table__table-menu" *ngIf="menuActive">\n        <ng-container\n          *ngIf="additionalActionsTemplate"\n          [ngTemplateOutlet]="additionalActionsTemplate"\n        >\n        </ng-container>\n      </ul>\n    </div>\n  </th>\n</tr>\n<tr *ngIf="config.searchEnabled && !filtersTemplate" class="ngx-table__sort-header">\n  <th *ngIf="config.checkboxes || config.radio"></th>\n  <ng-container *ngFor="let column of columns; let colIndex = index">\n    <th\n      [ngClass]="column.cssClass && column.cssClass.includeHeader ? column.cssClass.name : \'\'"\n      [class.pinned-left]="column.pinned"\n      [style.left]="styleService.pinnedWidth(column.pinned, colIndex)"\n    >\n      <table-header\n        *ngIf="getColumnDefinition(column)"\n        (update)="onSearch($event)"\n        [column]="column"\n      >\n      </table-header>\n    </th>\n  </ng-container>\n  <th *ngIf="config.additionalActions || config.detailsTemplate"></th>\n</tr>\n<ng-container *ngIf="filtersTemplate">\n  <tr>\n    <ng-container [ngTemplateOutlet]="filtersTemplate"> </ng-container>\n  </tr>\n</ng-container>\n',changeDetection:t.ChangeDetectionStrategy.OnPush,providers:[x],styles:["\n      .cdk-drag-preview {\n        text-align: left;\n        padding-top: 9px;\n        padding-left: 4px;\n        color: #50596c;\n        border: 1px solid #e7e9ed;\n      }\n    "]}]}],R.ctorParameters=function(){return[{type:x}]},R.propDecorators={config:[{type:t.Input}],columns:[{type:t.Input}],sortKey:[{type:t.Input}],sortState:[{type:t.Input}],selectAllTemplate:[{type:t.Input}],filtersTemplate:[{type:t.Input}],additionalActionsTemplate:[{type:t.Input}],filter:[{type:t.Output}],order:[{type:t.Output}],selectAll:[{type:t.Output}],event:[{type:t.Output}],th:[{type:t.ViewChild,args:["th"]}],additionalActionMenu:[{type:t.ViewChild,args:["additionalActionMenu"]}],onClick:[{type:t.HostListener,args:["document:click",["$event.target"]]}]};var T=function(){};T.decorators=[{type:t.NgModule,args:[{declarations:[b,w,y,R,k,C,v,S],imports:[e.CommonModule,r.NgxPaginationModule,o.DragDropModule,l.ScrollingModule],exports:[b]}]}];var P=function(){};P.decorators=[{type:t.NgModule,args:[{imports:[e.CommonModule,T],exports:[b],providers:[]}]}],n.BaseComponent=b,n.DefaultConfig=h,n.TableModule=P,n.a=m,n.b=T,n.c=f,n.d=x,n.e=w,n.f=y,n.g=R,n.h=k,n.i=C,n.j=v,n.k=S,Object.defineProperty(n,"__esModule",{value:!0})}));
//# sourceMappingURL=ngx-easy-table.umd.min.js.map